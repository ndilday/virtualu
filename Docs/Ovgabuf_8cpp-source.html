<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Ovgabuf.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.17 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>Ovgabuf.cpp</h1><a href="Ovgabuf_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">//Filename    : OVGABUF.CPP</span>
00002 <span class="comment">//Description : OVGABUF direct draw surface class</span>
00003 
00004 <span class="preprocessor">#include &lt;OVGABUF.H&gt;</span>
00005 <span class="preprocessor">#include &lt;<a class="code" href="OVGA_8H.html">OVGA.H</a>&gt;</span>
00006 <span class="preprocessor">#include &lt;<a class="code" href="OCOLTBL_8H.html">OCOLTBL.H</a>&gt;</span>
00007 <span class="preprocessor">#include &lt;<a class="code" href="ALL_8H.html">ALL.H</a>&gt;</span>
00008 <span class="preprocessor">#include &lt;OMOUSE.H&gt;</span>
00009 <span class="preprocessor">#include &lt;<a class="code" href="IMGFUN_8H.html">IMGFUN.H</a>&gt;</span>
00010 <span class="preprocessor">#include &lt;OSYS.H&gt;</span>
00011 <span class="preprocessor">#include &lt;<a class="code" href="OWORLD_8H.html">OWORLD.H</a>&gt;</span>
00012 <span class="preprocessor">#include &lt;<a class="code" href="OBITMAP_8H.html">OBITMAP.H</a>&gt;</span>
00013 <span class="preprocessor">#include &lt;<a class="code" href="OBITMAPW_8H.html">OBITMAPW.H</a>&gt;</span>
00014 
<a name="l00015"></a><a class="code" href="classVgaBuf.html#p7">00015</a> <span class="keywordtype">short</span> *<a class="code" href="classVgaBuf.html#p7">VgaBuf::default_remap_table</a>;
00016 
00017 <span class="comment">//-------- Begin of function VgaBuf::VgaBuf ----------//</span>
00018 
<a name="l00019"></a><a class="code" href="classVgaBuf.html#a7">00019</a> <a class="code" href="classVgaBuf.html#a7">VgaBuf::VgaBuf</a>() {
00020     memset( <span class="keyword">this</span>, 0, <span class="keyword">sizeof</span>(<a class="code" href="classVgaBuf.html">VgaBuf</a>) );
00021     <a class="code" href="classVgaBuf.html#a12">set_color</a>( <a class="code" href="COLOR_8H.html#a6">VGA_GRAY</a> );
00022 }
00023 
00024 <span class="comment">//-------- End of function VgaBuf::VgaBuf ----------//</span>
00025 
00026 <span class="comment">//-------- Begin of function VgaBuf::~VgaBuf ----------//</span>
00027 
<a name="l00028"></a><a class="code" href="classVgaBuf.html#a8">00028</a> <a class="code" href="classVgaBuf.html#a8">VgaBuf::~VgaBuf</a>() {
00029     <a class="code" href="classVgaBuf.html#a11">deinit</a>();
00030 }
00031 
00032 <span class="comment">//-------- End of function VgaBuf::~VgaBuf ----------//</span>
00033 
00034 <span class="comment">//-------- Begin of function VgaBuf::init_front ----------//</span>
<a name="l00038"></a><a class="code" href="classVgaBuf.html#a9">00038</a> <span class="comment">void VgaBuf::init_front(LPDIRECTDRAW4 ddPtr) {</span>
00039     DDSURFACEDESC2       ddsd;
00040     HRESULT             rc;
00041     DDCAPS              ddcaps;
00042 
00043     <span class="comment">//------ Get Direct Draw capacity info --------//</span>
00044 
00045     ddcaps.dwSize = <span class="keyword">sizeof</span>( ddcaps );
00046 
00047     <span class="keywordflow">if</span>( ddPtr-&gt;GetCaps( &amp;ddcaps, <a class="code" href="OHELP_8H.html#a0">NULL</a> ) != DD_OK )
00048         err.run( <span class="stringliteral">"Error creating Direct Draw front surface!"</span> );
00049 
00050     <span class="comment">//---------------------------------------------//</span>
00051     <span class="comment">// Create the Front Buffer</span>
00052     <span class="comment">//---------------------------------------------//</span>
00053 
00054     ZeroMemory( &amp;ddsd, <span class="keyword">sizeof</span>(ddsd) );
00055     ddsd.dwSize = <span class="keyword">sizeof</span>( ddsd );
00056 
00057     ddsd.dwFlags = DDSD_CAPS;
00058     ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
00059 
00060     <span class="comment">//  LPDIRECTDRAWSURFACE dd1Buf;</span>
00061     rc = ddPtr-&gt;CreateSurface( &amp;ddsd, &amp;dd_buf, <a class="code" href="OHELP_8H.html#a0">NULL</a> );
00062     <span class="keywordflow">if</span>( rc != DD_OK )
00063         err.run( <span class="stringliteral">"Error creating Direct Draw front surface!"</span> );
00064 
00065     <span class="comment">//  rc = dd1Buf-&gt;QueryInterface(IID_IDirectDrawSurface2, (void **)&amp;dd_buf);</span>
00066     <span class="comment">//  if( rc != DD_OK )</span>
00067     <span class="comment">//  {</span>
00068     <span class="comment">//          dd1Buf-&gt;Release();</span>
00069     <span class="comment">//          err.run ( "Error creating Direct Draw front surface!!" );</span>
00070     <span class="comment">//  }</span>
00071 
00072     <span class="comment">//  dd1Buf-&gt;Release();</span>
00073 
00074     lock_bit_stack = 0;
00075     lock_stack_count = 0;
00076 
00077     default_remap_table = vga.default_remap_table;  <span class="comment">// new for 16-bit</span>
00078 
00079     is_front = 1;
00080 }
00081 
00082 <span class="comment">//-------- End of function VgaBuf::init_front ----------//</span>
00083 
00084 <span class="comment">//-------- Begin of function VgaBuf::init_back ----------//</span>
<a name="l00091"></a><a class="code" href="classVgaBuf.html#a10">00091</a> <span class="comment">void VgaBuf::init_back( LPDIRECTDRAW4 ddPtr, DWORD w, DWORD h ) {</span>
00092     DDSURFACEDESC2       ddsd;
00093     HRESULT             rc;
00094 
00095     <span class="comment">//--------- fill in surface desc -----------//</span>
00096 
00097     memset( &amp;ddsd, 0, <span class="keyword">sizeof</span>( ddsd ) );
00098     ddsd.dwSize = <span class="keyword">sizeof</span>( ddsd );
00099     ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT |DDSD_WIDTH;
00100 
00101     ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
00102 
00103     ddsd.dwWidth  = w ? w : <a class="code" href="OVGA_8H.html#a0">VGA_WIDTH</a>;
00104     ddsd.dwHeight = h ? h : <a class="code" href="OVGA_8H.html#a1">VGA_HEIGHT</a>;
00105 
00106     <span class="comment">//  LPDIRECTDRAWSURFACE dd1Buf;</span>
00107     rc = ddPtr-&gt;CreateSurface( &amp;ddsd, &amp;dd_buf, <a class="code" href="OHELP_8H.html#a0">NULL</a> );
00108     <span class="keywordflow">if</span>( rc != DD_OK )
00109         err.run( <span class="stringliteral">"Error creating direct draw back surface!"</span> );
00110 
00111     <span class="comment">//  rc = dd1Buf-&gt;QueryInterface(IID_IDirectDrawSurface2, (void **)&amp;dd_buf);</span>
00112     <span class="comment">//  if( rc != DD_OK )</span>
00113     <span class="comment">//  {</span>
00114     <span class="comment">//          dd1Buf-&gt;Release();</span>
00115     <span class="comment">//          err.run( "Error creating direct draw back surface!!" );</span>
00116     <span class="comment">//  }</span>
00117 
00118     <span class="comment">//  dd1Buf-&gt;Release();</span>
00119 
00120     lock_bit_stack = 0;
00121     lock_stack_count = 0;
00122 
00123     default_remap_table = vga.default_remap_table;  <span class="comment">// new for 16-bit</span>
00124 }
00125 
00126 <span class="comment">//-------- End of function VgaBuf::init_back ----------//</span>
00127 
00128 <span class="comment">//------ Begin of function VgaBuf::deinit --------//</span>
00129 
<a name="l00130"></a><a class="code" href="classVgaBuf.html#a11">00130</a> <span class="keywordtype">void</span> <a class="code" href="classVgaBuf.html#a11">VgaBuf::deinit</a>() {
00131     <span class="keywordflow">if</span>( dd_buf ) {
00132         <a class="code" href="classVgaBuf.html#m0">dd_buf</a>-&gt;Release();
00133         <a class="code" href="classVgaBuf.html#m0">dd_buf</a> = <a class="code" href="OHELP_8H.html#a0">NULL</a>;
00134     }
00135 }
00136 
00137 <span class="comment">//-------- End of function VgaBuf::deinit ----------//</span>
00138 
00139 <span class="comment">//-------- Begin of function VgaBuf::activate_pal ----------//</span>
<a name="l00143"></a><a class="code" href="classVgaBuf.html#a15">00143</a> <span class="comment">void VgaBuf::activate_pal(LPDIRECTDRAWPALETTE ddPalPtr) {</span>
00144     <span class="keywordflow">return</span>;                                         <span class="comment">// no need for 16-bit</span>
00145 
00146     <a class="code" href="ALL_8H.html#a0">err_when</a>(!ddPalPtr || !dd_buf);
00147 
00148     HRESULT rc = dd_buf-&gt;SetPalette(ddPalPtr);
00149 
00150     <span class="keywordflow">if</span>( rc == DDERR_SURFACELOST ) {
00151         dd_buf-&gt;Restore();
00152         rc = dd_buf-&gt;SetPalette(ddPalPtr);
00153     }
00154 
00155 <span class="preprocessor">#ifdef DEBUG</span>
00156 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( rc != DD_OK )
00157         debug_msg( <span class="stringliteral">"VgaBuf::activate_pal(), failed activating the palette"</span> );
00158 <span class="preprocessor">#endif</span>
00159 <span class="preprocessor"></span>}
00160 
00161 <span class="comment">//--------- End of function VgaBuf::activate_pal ----------//</span>
00162 
00163 <span class="comment">//-------- Begin of function VgaBuf::color_match ----------//</span>
00164 
<a name="l00165"></a><a class="code" href="classVgaBuf.html#a16">00165</a> DWORD <a class="code" href="classVgaBuf.html#a16">VgaBuf::color_match</a>(COLORREF rgb) {
00166     COLORREF    rgbT;
00167     HDC         hdc;
00168     DWORD       dw = CLR_INVALID;
00169     DDSURFACEDESC2  ddsd;
00170     HRESULT       hres;
00171 
00172     <span class="keywordflow">if</span>( <a class="code" href="classVgaBuf.html#m0">dd_buf</a>-&gt;GetDC(&amp;hdc) == DD_OK ) {
00173         rgbT = GetPixel(hdc, 0, 0);
00174         SetPixel(hdc, 0, 0, rgb);
00175         <a class="code" href="classVgaBuf.html#m0">dd_buf</a>-&gt;ReleaseDC(hdc);
00176     }
00177 
00178     ddsd.dwSize = <span class="keyword">sizeof</span>(ddsd);
00179     hres = <a class="code" href="classVgaBuf.html#m0">dd_buf</a>-&gt;Lock(<a class="code" href="OHELP_8H.html#a0">NULL</a>, &amp;ddsd, DDLOCK_WAIT, <a class="code" href="OHELP_8H.html#a0">NULL</a>);
00180 
00181     <span class="keywordflow">if</span> (hres == DD_OK) {
00182         dw  = *(DWORD *)ddsd.lpSurface;
00183         dw &amp;= (1 &lt;&lt; ddsd.ddpfPixelFormat.dwRGBBitCount)-1;
00184         <a class="code" href="classVgaBuf.html#m0">dd_buf</a>-&gt;Unlock(<a class="code" href="OHELP_8H.html#a0">NULL</a>);
00185     }
00186 
00187     <span class="keywordflow">if</span> (<a class="code" href="classVgaBuf.html#m0">dd_buf</a>-&gt;GetDC(&amp;hdc) == DD_OK) {
00188         SetPixel(hdc, 0, 0, rgbT);
00189         <a class="code" href="classVgaBuf.html#m0">dd_buf</a>-&gt;ReleaseDC(hdc);
00190     }
00191 
00192     <span class="keywordflow">return</span> dw;
00193 }
00194 
00195 <span class="comment">//-------- End Endof function VgaBuf::color_match ----------//</span>
00196 
00197 <span class="comment">//-------- Begin of function VgaBuf::is_buf_lost ----------//</span>
<a name="l00199"></a><a class="code" href="classVgaBuf.html#a13">00199</a> <span class="comment">BOOL VgaBuf::is_buf_lost() {</span>
00200     <span class="keywordflow">return</span> dd_buf &amp;&amp; dd_buf-&gt;IsLost() == DDERR_SURFACELOST;
00201 }
00202 
00203 <span class="comment">//--------- End of function VgaBuf::is_buf_lost ----------//</span>
00204 
00205 <span class="comment">//-------- Begin of function VgaBuf::restore_buf ----------//</span>
<a name="l00209"></a><a class="code" href="classVgaBuf.html#a14">00209</a> <span class="comment">BOOL VgaBuf::restore_buf() {</span>
00210     <span class="keywordflow">if</span>( dd_buf == <a class="code" href="OHELP_8H.html#a0">NULL</a> || dd_buf-&gt;Restore() != DD_OK ) {
00211 <span class="preprocessor">#ifdef DEBUG</span>
00212 <span class="preprocessor"></span>        debug_msg(<span class="stringliteral">"Error restoring direct draw buffer"</span>);
00213 <span class="preprocessor">#endif</span>
00214 <span class="preprocessor"></span>        <span class="keywordflow">return</span> FALSE;
00215     }
00216 
00217     <span class="keywordflow">return</span> TRUE;
00218 }
00219 
00220 <span class="comment">//--------- End of function VgaBuf::restore_buf ----------//</span>
00221 
00222 <span class="comment">//------------- Begin of function VgaBuf::lock_buf --------------//</span>
00223 
<a name="l00224"></a><a class="code" href="classVgaBuf.html#a17">00224</a> <span class="keywordtype">void</span> <a class="code" href="classVgaBuf.html#a17">VgaBuf::lock_buf</a>() {
00225     <a class="code" href="ALL_8H.html#a2">err_if</a>( <a class="code" href="classVgaBuf.html#m2">buf_locked</a> )
00226         <a class="code" href="ALL_8H.html#a4">err_now</a>( <span class="stringliteral">"VgaBuf::lock_buf() error, buffer already locked."</span> );
00227 
00228     memset( &amp;<a class="code" href="classVgaBuf.html#m1">buf_des</a>, 0, <span class="keyword">sizeof</span>(<a class="code" href="classVgaBuf.html#m1">buf_des</a>) );
00229 
00230     <a class="code" href="classVgaBuf.html#m1">buf_des</a>.dwSize = <span class="keyword">sizeof</span>(buf_des);
00231 
00232     <span class="keywordtype">int</span> rc = <a class="code" href="classVgaBuf.html#m0">dd_buf</a>-&gt;Lock(<a class="code" href="OHELP_8H.html#a0">NULL</a>, &amp;<a class="code" href="classVgaBuf.html#m1">buf_des</a>, DDLOCK_WAIT, <a class="code" href="OHELP_8H.html#a0">NULL</a>);
00233 
00234     <a class="code" href="classVgaBuf.html#m3">cur_buf_ptr</a> = (<span class="keywordtype">short</span> *) <a class="code" href="classVgaBuf.html#m1">buf_des</a>.lpSurface;
00235 
00236     <span class="comment">//--------------------------------------//</span>
00237 
00238     <span class="keywordflow">if</span>( rc==DD_OK )
00239         <a class="code" href="classVgaBuf.html#m2">buf_locked</a> = TRUE;
00240     <span class="keywordflow">else</span> {
00241         <span class="keywordflow">if</span>( is_front )
00242             <a class="code" href="ALL_8H.html#a4">err_now</a>( <span class="stringliteral">"VgaBuf::lock_buf() locking front buffer failed."</span> );
00243         <span class="keywordflow">else</span>
00244             <a class="code" href="ALL_8H.html#a4">err_now</a>( <span class="stringliteral">"VgaBuf::lock_buf() locking back buffer failed."</span> );
00245 
00246 <span class="preprocessor">#ifdef DEBUG</span>
00247 <span class="preprocessor"></span>        debug_msg( <span class="stringliteral">"Failed to lock the buffer."</span> );
00248 <span class="preprocessor">#endif</span>
00249 <span class="preprocessor"></span>    }
00250 }
00251 
00252 <span class="comment">//--------------- End of function VgaBuf::lock_buf --------------//</span>
00253 
00254 <span class="comment">//------------- Begin of function VgaBuf::unlock_buf --------------//</span>
00255 
<a name="l00256"></a><a class="code" href="classVgaBuf.html#a18">00256</a> <span class="keywordtype">void</span> <a class="code" href="classVgaBuf.html#a18">VgaBuf::unlock_buf</a>() {
00257     <span class="comment">// ####### begin Gilbert 16/9 #####//</span>
00258     <span class="keywordflow">if</span>( !<a class="code" href="classVgaBuf.html#m0">dd_buf</a> )
00259         <span class="keywordflow">return</span>;
00260     <span class="comment">// ####### end Gilbert 16/9 #####//</span>
00261 
00262     <a class="code" href="ALL_8H.html#a0">err_when</a>( !<a class="code" href="classVgaBuf.html#m2">buf_locked</a> );
00263 
00264     <span class="keywordtype">int</span> rc = <a class="code" href="classVgaBuf.html#m0">dd_buf</a>-&gt;Unlock(<a class="code" href="OHELP_8H.html#a0">NULL</a>);
00265 
00266     <span class="keywordflow">if</span>( rc==DD_OK )
00267         <a class="code" href="classVgaBuf.html#m2">buf_locked</a> = FALSE;
00268     <span class="keywordflow">else</span> {
00269         <span class="keywordflow">switch</span>(rc) {
00270         <span class="keywordflow">case</span> DDERR_INVALIDOBJECT:
00271             <a class="code" href="ALL_8H.html#a4">err_now</a>( <span class="stringliteral">"VgaBuf::unlock_buf error: DDERR_INVALIDOBJECT"</span> );
00272 
00273         <span class="keywordflow">case</span> DDERR_INVALIDPARAMS:
00274             <a class="code" href="ALL_8H.html#a4">err_now</a>( <span class="stringliteral">"VgaBuf::unlock_buf error: DDERR_INVALIDPARAMS"</span> );
00275 
00276         <span class="keywordflow">case</span> DDERR_INVALIDRECT:
00277             <a class="code" href="ALL_8H.html#a4">err_now</a>( <span class="stringliteral">"VgaBuf::unlock_buf error: DDERR_INVALIDRECT"</span> );
00278 
00279         <span class="keywordflow">case</span> DDERR_NOTLOCKED:
00280             <a class="code" href="ALL_8H.html#a4">err_now</a>( <span class="stringliteral">"VgaBuf::unlock_buf error: DDERR_NOTLOCKED"</span> );
00281 
00282         <span class="keywordflow">case</span> DDERR_SURFACELOST:
00283             <a class="code" href="ALL_8H.html#a4">err_now</a>( <span class="stringliteral">"VgaBuf::unlock_buf error: DDERR_SURFACELOST"</span> );
00284         }
00285 
00286         <span class="keywordflow">if</span>( is_front )
00287             <a class="code" href="ALL_8H.html#a4">err_now</a>( <span class="stringliteral">"VgaBuf::unlock_buf() unlocking front buffer failed."</span> );
00288         <span class="keywordflow">else</span>
00289             <a class="code" href="ALL_8H.html#a4">err_now</a>( <span class="stringliteral">"VgaBuf::unlock_buf() unlocking back buffer failed."</span> );
00290 
00291 <span class="preprocessor">#ifdef DEBUG</span>
00292 <span class="preprocessor"></span>        debug_msg( <span class="stringliteral">"Failed to unlock the buffer."</span> );
00293 <span class="preprocessor">#endif</span>
00294 <span class="preprocessor"></span>    }
00295 }
00296 
00297 <span class="comment">//--------------- End of function VgaBuf::unlock_buf --------------//</span>
00298 
00299 <span class="comment">//------------- Begin of function VgaBuf::temp_unlock --------------//</span>
<a name="l00303"></a><a class="code" href="classVgaBuf.html#a19">00303</a> <span class="comment">void VgaBuf::temp_unlock() {</span>
00304     <span class="comment">// push buf_locked</span>
00305     <a class="code" href="ALL_8H.html#a0">err_when</a>(lock_stack_count &gt;= <span class="keyword">sizeof</span>(lock_bit_stack)*8);
00306     <a class="code" href="ALL_8H.html#a0">err_when</a>(buf_locked != 0 &amp;&amp; buf_locked != 1);   <span class="comment">// 0 or 1</span>
00307     lock_bit_stack = (lock_bit_stack &lt;&lt; 1) | buf_locked;
00308     ++lock_stack_count;
00309 
00310     <span class="keywordflow">if</span>( buf_locked )
00311         unlock_buf();
00312 
00313     <a class="code" href="ALL_8H.html#a0">err_when</a>( buf_locked );
00314 }
00315 
00316 <span class="comment">//--------------- End of function VgaBuf::temp_unlock --------------//</span>
00317 
00318 <span class="comment">//------------- Begin of function VgaBuf::temp_restore_lock --------------//</span>
<a name="l00323"></a><a class="code" href="classVgaBuf.html#a20">00323</a> <span class="comment">void VgaBuf::temp_restore_lock() {</span>
00324     <span class="comment">// pop buf_locked</span>
00325     <a class="code" href="ALL_8H.html#a0">err_when</a>(lock_stack_count==0);
00326     DWORD newBufLocked = lock_bit_stack &amp; 1;
00327     lock_bit_stack &gt;&gt;= 1;
00328     lock_stack_count--;
00329 
00330     <span class="keywordflow">if</span>( newBufLocked )
00331         lock_buf();
00332 }
00333 
00334 <span class="comment">//--------------- End of function VgaBuf::temp_restore_lock --------------//</span>
00335 
00336 <span class="comment">//------------- Begin of function VgaBuf::temp_lock --------------//</span>
<a name="l00340"></a><a class="code" href="classVgaBuf.html#a21">00340</a> <span class="comment">void VgaBuf::temp_lock() {</span>
00341     <span class="comment">// push buf_locked</span>
00342     <a class="code" href="ALL_8H.html#a0">err_when</a>(lock_stack_count &gt;= <span class="keyword">sizeof</span>(lock_bit_stack)*8);
00343     <a class="code" href="ALL_8H.html#a0">err_when</a>(buf_locked != 0 &amp;&amp; buf_locked != 1);   <span class="comment">// 0 or 1</span>
00344     lock_bit_stack = (lock_bit_stack &lt;&lt; 1) | buf_locked;
00345     ++lock_stack_count;
00346 
00347     <span class="keywordflow">if</span>( !buf_locked )
00348         lock_buf();
00349     <a class="code" href="ALL_8H.html#a0">err_when</a>( !buf_locked );
00350 }
00351 
00352 <span class="comment">//------------- End of function VgaBuf::temp_lock --------------//</span>
00353 
00354 <span class="comment">//------------- Begin of function VgaBuf::temp_restore_unlock --------------//</span>
<a name="l00359"></a><a class="code" href="classVgaBuf.html#a22">00359</a> <span class="comment">void VgaBuf::temp_restore_unlock() {</span>
00360     <span class="comment">// pop buf_locked</span>
00361     <a class="code" href="ALL_8H.html#a0">err_when</a>(lock_stack_count==0);
00362     DWORD newBufLocked = lock_bit_stack &amp; 1;
00363     lock_bit_stack &gt;&gt;= 1;
00364     lock_stack_count--;
00365 
00366     <span class="keywordflow">if</span>( !newBufLocked )
00367         unlock_buf();
00368 }
00369 
00370 <span class="comment">//------------- End of function VgaBuf::temp_restore_unlock --------------//</span>
00371 
00372 <span class="comment">//------------- Begin of function VgaBuf::put_bitmap --------------//</span>
<a name="l00376"></a><a class="code" href="classVgaBuf.html#a57">00376</a> <span class="comment">void VgaBuf::put_bitmap(int x,int y,char* bitmapPtr) {</span>
00377     <a class="code" href="ALL_8H.html#a0">err_when</a>( !buf_locked );
00378 
00379     <span class="keywordflow">if</span>( is_front )
00380         mouse.hide_area( x, y, x+*((<span class="keywordtype">short</span>*)bitmapPtr)-1, y+*(((<span class="keywordtype">short</span>*)bitmapPtr)+1)-1 );
00381 
00382     <span class="comment">//  ##chwg1130</span>
00383     <span class="keywordflow">if</span>((bitmapPtr[0]==-1)&amp;&amp;(bitmapPtr[1]==-1)) {
00384         <span class="comment">//create new 16bit palette</span>
00385         <span class="keywordtype">short</span> newPalette[256];
00386         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0,p=2;i&lt;256;i++,p+=<span class="keyword">sizeof</span>(RGBColor))
00387             newPalette[i] = (short)vga.make_pixel(
00388                 (BYTE)bitmapPtr[p] &lt;&lt; 2,
00389                 (BYTE)bitmapPtr[p+1] &lt;&lt; 2,
00390                 (BYTE)bitmapPtr[p+2] &lt;&lt; 2);
00391         <span class="comment">//                newPalette[i] = (short)vga.make_pixel( (RGBColor *)(bitmapPtr + p) );</span>
00392         put_bitmap_remap(x,y,bitmapPtr+p,newPalette);
00393     }
00394     <span class="keywordflow">else</span>
00395         <a class="code" href="IMGFUN_8H.html#a10">IMGbltRemap</a>(buf_ptr(), buf_true_pitch(), x, y, bitmapPtr, default_remap_table);
00396 
00397     <span class="keywordflow">if</span>( is_front )
00398         mouse.show_area();
00399 }
00400 
00401 <span class="comment">//--------------- End of function VgaBuf::put_bitmap --------------//</span>
00402 
00403 <span class="comment">//------- Begin of function VgaBuf::put_bitmap_trans --------//</span>
<a name="l00407"></a><a class="code" href="classVgaBuf.html#a66">00407</a> <span class="comment">void VgaBuf::put_bitmap_trans(int x,int y,char* bitmapPtr) {</span>
00408     <a class="code" href="ALL_8H.html#a0">err_when</a>( !buf_locked );
00409 
00410     <span class="keywordflow">if</span>( is_front )
00411         mouse.hide_area( x, y, x+*((<span class="keywordtype">short</span>*)bitmapPtr)-1, y+*(((<span class="keywordtype">short</span>*)bitmapPtr)+1)-1 );
00412 
00413     <span class="comment">//  ##chwg1130</span>
00414     <span class="keywordflow">if</span>((bitmapPtr[0]==-1)&amp;&amp;(bitmapPtr[1]==-1)) {
00415         <span class="comment">//create new 16bit palette</span>
00416         <span class="keywordtype">short</span> newPalette[256];
00417         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0,p=2;i&lt;256;i++,p+=<span class="keyword">sizeof</span>(RGBColor))
00418             newPalette[i] = (short)vga.make_pixel(
00419                 (BYTE)bitmapPtr[p] &lt;&lt; 2,
00420                 (BYTE)bitmapPtr[p+1] &lt;&lt; 2,
00421                 (BYTE)bitmapPtr[p+2] &lt;&lt; 2);
00422         <a class="code" href="IMGFUN_8H.html#a14">IMGbltTransRemap</a>(buf_ptr(), buf_true_pitch(), x, y, bitmapPtr+p,newPalette);
00423     }
00424     <span class="keywordflow">else</span>
00425         <a class="code" href="IMGFUN_8H.html#a14">IMGbltTransRemap</a>(buf_ptr(), buf_true_pitch(), x, y, bitmapPtr, default_remap_table);
00426 
00427     <span class="keywordflow">if</span>( is_front )
00428         mouse.show_area();
00429 }
00430 
00431 <span class="comment">//--------- End of function VgaBuf::put_bitmap_trans --------//</span>
00432 
00433 <span class="comment">//------- Begin of function VgaBuf::put_bitmap_remap --------//</span>
<a name="l00437"></a><a class="code" href="classVgaBuf.html#a61">00437</a> <span class="comment">void VgaBuf::put_bitmap_remap(int x,int y,char* bitmapPtr,short *colorTable) {</span>
00438     <a class="code" href="ALL_8H.html#a0">err_when</a>( !buf_locked );
00439 
00440     <span class="keywordflow">if</span>( is_front )
00441         mouse.hide_area( x, y, x+((<a class="code" href="classBitmap.html">Bitmap</a> *)bitmapPtr)-&gt;get_width()-1, y+((<a class="code" href="classBitmap.html">Bitmap</a>*)bitmapPtr)-&gt;get_height()-1 );
00442 
00443     <a class="code" href="IMGFUN_8H.html#a10">IMGbltRemap</a>(buf_ptr(), buf_true_pitch(), x, y, bitmapPtr, colorTable);
00444 
00445     <span class="keywordflow">if</span>( is_front )
00446         mouse.show_area();
00447 }
00448 
00449 <span class="comment">//--------- End of function VgaBuf::put_bitmap_remap --------//</span>
00450 
00451 <span class="comment">//---------- Begin of function VgaBuf::save_area_common_buf ----------//</span>
<a name="l00455"></a><a class="code" href="classVgaBuf.html#a53">00455</a> <span class="comment">void VgaBuf::save_area_common_buf(int x1, int y1, int x2, int y2) {</span>
00456     <a class="code" href="ALL_8H.html#a0">err_when</a>( x1&gt;x2 || y1&gt;y2 || x1&lt;0 || y1&lt;0 || x2&gt;=<a class="code" href="OVGA_8H.html#a0">VGA_WIDTH</a> || y2&gt;=<a class="code" href="OVGA_8H.html#a1">VGA_HEIGHT</a> );
00457 
00458     <span class="keywordtype">long</span> saveSize = <span class="keyword">sizeof</span>(short)*4 + <a class="code" href="classBitmapW.html#a7">BitmapW::size</a>(x2-x1+1, y2-y1+1);
00459 
00460     <a class="code" href="ALL_8H.html#a2">err_if</a>( saveSize &gt; <a class="code" href="Osys_8h.html#a40a2">COMMON_DATA_BUF_SIZE</a> )
00461         <a class="code" href="ALL_8H.html#a4">err_now</a>( <span class="stringliteral">"VgaBuf::save_area_common_buf()"</span> );
00462 
00463     <span class="keywordtype">short</span>* shortPtr = (<span class="keywordtype">short</span>*) sys.common_data_buf;
00464 
00465     *shortPtr++ = x1;
00466     *shortPtr++ = y1;
00467     *shortPtr++ = x2;
00468     *shortPtr++ = y2;
00469 
00470     <span class="comment">//-------- read screen ---------//</span>
00471 
00472     <span class="keywordflow">if</span>( is_front )
00473         mouse.hide_area( x1,y1,x2,y2 );               <span class="comment">// if the mouse cursor is in that area, hide it</span>
00474 
00475     read_bitmapW( x1,y1,x2,y2, shortPtr );
00476 
00477     <span class="keywordflow">if</span>( is_front )
00478         mouse.show_area();
00479 }
00480 
00481 <span class="comment">//------------ End of function VgaBuf::save_area_common_buf ----------//</span>
00482 
00483 <span class="comment">//---------- Begin of function VgaBuf::rest_area_common_buf ----------//</span>
<a name="l00488"></a><a class="code" href="classVgaBuf.html#a54">00488</a> <span class="comment">void VgaBuf::rest_area_common_buf() {</span>
00489     <span class="keywordtype">short</span>* shortPtr = (<span class="keywordtype">short</span>*) sys.common_data_buf;
00490 
00491     <span class="keywordtype">int</span> x1 = *shortPtr++;
00492     <span class="keywordtype">int</span> y1 = *shortPtr++;
00493     <span class="keywordtype">int</span> x2 = *shortPtr++;
00494     <span class="keywordtype">int</span> y2 = *shortPtr++;
00495 
00496     put_bitmapW( x1, y1, shortPtr );
00497 }
00498 
00499 <span class="comment">//------------ End of function VgaBuf::rest_area_common_buf ----------//</span>
00500 
00501 <span class="comment">//---------- Begin of function VgaBuf::save_area ---------//</span>
<a name="l00512"></a><a class="code" href="classVgaBuf.html#a50">00512</a> <span class="comment">short* VgaBuf::save_area(int x1, int y1, int x2, int y2, short* saveScr ) {</span>
00513     <a class="code" href="ALL_8H.html#a0">err_when</a>( x1&gt;x2 || y1&gt;y2 || x1&lt;0 || y1&lt;0 || x2&gt;=<a class="code" href="OVGA_8H.html#a0">VGA_WIDTH</a> || y2&gt;=<a class="code" href="OVGA_8H.html#a1">VGA_HEIGHT</a> );
00514 
00515     <span class="keywordtype">long</span> newSize = <span class="keyword">sizeof</span>(short)*4 + <a class="code" href="classBitmapW.html#a7">BitmapW::size</a>((x2-x1+1),(y2-y1+1));
00516 
00517     saveScr = (<span class="keywordtype">short</span> *)<a class="code" href="ALL_8H.html#a7">mem_resize</a>( saveScr, newSize );
00518 
00519     <span class="keywordtype">short</span>* shortPtr = (<span class="keywordtype">short</span>*) saveScr;
00520 
00521     *shortPtr++ = x1;
00522     *shortPtr++ = y1;
00523     *shortPtr++ = x2;
00524     *shortPtr++ = y2;
00525 
00526     <span class="keywordflow">if</span>( is_front )
00527         mouse.hide_area( x1,y1,x2,y2 );               <span class="comment">// if the mouse cursor is in that area, hide it</span>
00528 
00529     read_bitmapW( x1,y1,x2,y2, shortPtr );
00530 
00531     <span class="keywordflow">if</span>( is_front )
00532         mouse.show_area();
00533 
00534     <span class="keywordflow">return</span> saveScr;
00535 }
00536 
00537 <span class="comment">//------------ End of function VgaBuf::save_area ---------//</span>
00538 
00539 <span class="comment">// ---  begin  ##chwg1021 --- //</span>
00540 <span class="comment">//----------- Begin of function VgaBuf::rest_area_with_clipping --------//</span>
<a name="l00553"></a><a class="code" href="classVgaBuf.html#a52">00553</a> <span class="comment">void VgaBuf::rest_area_with_clipping(short* saveScr,</span>
00554                                      <span class="keywordtype">int</span> cx1, <span class="keywordtype">int</span> cy1,
00555                                      <span class="keywordtype">int</span> cx2, <span class="keywordtype">int</span> cy2,
00556                                      <span class="keywordtype">int</span> releaseFlag, <span class="keywordtype">int</span> transparentFlag) {
00557     <span class="keywordtype">int</span> x1,y1,x2,y2;
00558 
00559     <span class="keywordflow">if</span>( saveScr == <a class="code" href="OHELP_8H.html#a0">NULL</a> )
00560         <span class="keywordflow">return</span>;
00561 
00562     <span class="keywordtype">short</span>* shortPtr = (<span class="keywordtype">short</span>*) saveScr;
00563 
00564     x1 = *shortPtr++;
00565     y1 = *shortPtr++;
00566     x2 = *shortPtr++;
00567     y2 = *shortPtr++;
00568 
00569     <a class="code" href="ALL_8H.html#a0">err_when</a>( x1&gt;x2 || y1&gt;y2 || x1&lt;0 || y1&lt;0 || x2&gt;=<a class="code" href="OVGA_8H.html#a0">VGA_WIDTH</a> || y2&gt;=<a class="code" href="OVGA_8H.html#a1">VGA_HEIGHT</a> );
00570 
00571     <span class="keywordflow">if</span>( transparentFlag )
00572         put_bitmapW_area_trans( x1, y1, shortPtr, cx1, cy1, cx2, cy2);
00573     <span class="keywordflow">else</span>
00574         put_bitmapW_area( x1, y1, shortPtr, cx1, cy1, cx2, cy2);
00575 
00576     <span class="keywordflow">if</span>( releaseFlag )
00577         <a class="code" href="ALL_8H.html#a8">mem_del</a>( saveScr );
00578 }
00579 
00580 <span class="comment">//------------ End of function VgaBuf::rest_area_with_clipping ----------//</span>
00581 <span class="comment">// ---  end  ##chwg1021 --- //</span>
00582 
00583 <span class="comment">//----------- Begin of function VgaBuf::rest_area --------//</span>
<a name="l00592"></a><a class="code" href="classVgaBuf.html#a51">00592</a> <span class="comment">void VgaBuf::rest_area(short* saveScr, int releaseFlag, int transparentFlag) {</span>
00593     <span class="keywordtype">int</span>  x1,y1,x2,y2;
00594 
00595     <span class="keywordflow">if</span>( saveScr == <a class="code" href="OHELP_8H.html#a0">NULL</a> )
00596         <span class="keywordflow">return</span>;
00597 
00598     <span class="keywordtype">short</span>* shortPtr = (<span class="keywordtype">short</span>*) saveScr;
00599 
00600     x1 = *shortPtr++;
00601     y1 = *shortPtr++;
00602     x2 = *shortPtr++;
00603     y2 = *shortPtr++;
00604 
00605     <a class="code" href="ALL_8H.html#a0">err_when</a>( x1&gt;x2 || y1&gt;y2 || x1&lt;0 || y1&lt;0 || x2&gt;=<a class="code" href="OVGA_8H.html#a0">VGA_WIDTH</a> || y2&gt;=<a class="code" href="OVGA_8H.html#a1">VGA_HEIGHT</a> );
00606 
00607     <span class="keywordflow">if</span>( transparentFlag )
00608         put_bitmapW_trans( x1, y1, shortPtr );
00609     <span class="keywordflow">else</span>
00610         put_bitmapW( x1, y1, shortPtr );
00611 
00612     <span class="keywordflow">if</span>( releaseFlag )
00613         <a class="code" href="ALL_8H.html#a8">mem_del</a>( saveScr );
00614 }
00615 
00616 <span class="comment">//------------ End of function VgaBuf::rest_area ----------//</span>
00617 
00619 <span class="comment">// old version 8 bit //</span>
00621 <span class="comment">//------------ Begin of function VgaBuf::write_bmp_file --------------//</span>
00629 <span class="comment">/*</span>
00630 <span class="keywordtype">int</span> <a class="code" href="classVgaBuf.html#a25">VgaBuf::write_bmp_file</a>(<span class="keywordtype">char</span>* fileName)
00631 {
00632    <a class="code" href="classFile.html">File</a>                         bmpFile;
00633    BITMAPINFO*  bmpInfoPtr = <a class="code" href="OHELP_8H.html#a0">NULL</a>;
00634    <span class="keywordtype">char</span>*                        bitmapPtr = <a class="code" href="OHELP_8H.html#a0">NULL</a>;
00635 
00636    bmpFile.<a class="code" href="classFile.html#a3">file_create</a>(fileName, 1, 0);         <span class="comment">// 1-handle error, 0-disable variable file size</span>
00637 
00638    <span class="comment">//------------ Write the file header ------------//</span>
00639 
00640 BITMAPFILEHEADER bmpFileHdr;
00641 
00642 bmpFileHdr.bfType               = 0x4D42;                       <span class="comment">// set the type to "BM"</span>
00643 bmpFileHdr.bfSize               = <a class="code" href="classVgaBuf.html#a4">buf_size</a>();
00644 bmpFileHdr.bfReserved1 = 0;
00645 bmpFileHdr.bfReserved2 = 0;
00646 bmpFileHdr.bfOffBits   = <span class="keyword">sizeof</span>(BITMAPFILEHEADER) + <span class="keyword">sizeof</span>(BITMAPINFOHEADER) + <span class="keyword">sizeof</span>(RGBQUAD)*256;
00647 
00648 bmpFile.<a class="code" href="classFile.html#a10">file_write</a>(&amp;bmpFileHdr, <span class="keyword">sizeof</span>(bmpFileHdr));
00649 
00650 <span class="comment">//------------ Write in the info header -----------//</span>
00651 
00652 BITMAPINFOHEADER bmpInfoHdr;
00653 
00654 bmpInfoHdr.biSize                        = <span class="keyword">sizeof</span>(BITMAPINFOHEADER);
00655 bmpInfoHdr.biWidth                       = <a class="code" href="classVgaBuf.html#m1">buf_des</a>.dwWidth;
00656 bmpInfoHdr.biHeight                      = <a class="code" href="classVgaBuf.html#m1">buf_des</a>.dwHeight;
00657 bmpInfoHdr.biPlanes                      = 1;
00658 bmpInfoHdr.biBitCount            = 8;
00659 bmpInfoHdr.biCompression         = BI_RGB;
00660 bmpInfoHdr.biSizeImage      = <a class="code" href="classVgaBuf.html#a4">buf_size</a>();
00661 bmpInfoHdr.biXPelsPerMeter = 0;
00662 bmpInfoHdr.biYPelsPerMeter = 0;
00663 bmpInfoHdr.biClrUsed             = 0;
00664 bmpInfoHdr.biClrImportant  = 0;
00665 
00666 bmpFile.<a class="code" href="classFile.html#a10">file_write</a>(&amp;bmpInfoHdr, <span class="keyword">sizeof</span>(bmpInfoHdr));
00667 
00668 <span class="comment">//------------ write the color table -----------//</span>
00669 
00670 LPDIRECTDRAWPALETTE ddPalettePtr;                               <span class="comment">// get the direct draw surface's palette</span>
00671 <a class="code" href="classVgaBuf.html#m0">dd_buf</a>-&gt;GetPalette(&amp;ddPalettePtr);
00672 
00673 PALETTEENTRY *palEntries = (PALETTEENTRY*) <a class="code" href="ALL_8H.html#a5">mem_add</a>( <span class="keyword">sizeof</span>(PALETTEENTRY)*256 );
00674 ddPalettePtr-&gt;GetEntries(0, 0, 256, palEntries);
00675 
00676 RGBQUAD *colorTable = (RGBQUAD*) <a class="code" href="ALL_8H.html#a5">mem_add</a>( <span class="keyword">sizeof</span>(RGBQUAD)*256 );                <span class="comment">// allocate a color table with 256 entries</span>
00677 
00678 <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i=0 ; i&lt;256 ; i++ )
00679 {
00680 colorTable[i].rgbBlue  = palEntries[i].peBlue;
00681 colorTable[i].rgbGreen = palEntries[i].peGreen;
00682 colorTable[i].rgbRed   = palEntries[i].peRed;
00683 colorTable[i].rgbReserved = 0;
00684 }
00685 
00686 bmpFile.<a class="code" href="classFile.html#a10">file_write</a>(colorTable, <span class="keyword">sizeof</span>(RGBQUAD)*256);
00687 
00688 <a class="code" href="ALL_8H.html#a8">mem_del</a>(palEntries);
00689 <a class="code" href="ALL_8H.html#a8">mem_del</a>(colorTable);
00690 
00691 <span class="comment">//----------- write the bitmap ----------//</span>
00692 
00693 <span class="keywordflow">for</span>( <span class="keywordtype">int</span> y=<a class="code" href="classVgaBuf.html#a6">buf_height</a>()-1 ; y&gt;=0 ; y-- )                                        <span class="comment">// write in reversed order as DIB's vertical order is reversed</span>
00694 bmpFile.<a class="code" href="classFile.html#a10">file_write</a>(<a class="code" href="classVgaBuf.html#a0">buf_ptr</a>(0,y), <a class="code" href="classVgaBuf.html#a5">buf_width</a>());
00695 
00696 <span class="comment">//------------ close the file -----------//</span>
00697 
00698 bmpFile.<a class="code" href="classFile.html#a5">file_close</a>();
00699 
00700 <span class="keywordflow">return</span> 1;
00701 }
00702 <span class="comment">//------------ End of function VgaBuf::write_bmp_file --------------//</span>
00703 */
00704 
00705 <span class="comment">//------------ Begin of function VgaBuf::write_bmp_file --------------//</span>
<a name="l00713"></a><a class="code" href="classVgaBuf.html#a25">00713</a> <span class="comment">int VgaBuf::write_bmp_file(char* fileName) {</span>
00714     <a class="code" href="classFile.html">File</a>       bmpFile;
00715     BITMAPINFO*  bmpInfoPtr = <a class="code" href="OHELP_8H.html#a0">NULL</a>;
00716     <span class="keywordtype">char</span>*      bitmapPtr = <a class="code" href="OHELP_8H.html#a0">NULL</a>;
00717 
00718     <span class="keywordtype">int</span>        hasPaletteFlag = 0;
00719 
00720     bmpFile.<a class="code" href="classFile.html#a3">file_create</a>(fileName, 1, 0);            <span class="comment">// 1-handle error, 0-disable variable file size</span>
00721 
00722     <span class="comment">//------------ Write the file header ------------//</span>
00723 
00724     BITMAPFILEHEADER bmpFileHdr;
00725 
00726     bmpFileHdr.bfType    = 0x4D42;                  <span class="comment">// set the type to "BM"</span>
00727     bmpFileHdr.bfSize    = buf_size();
00728     bmpFileHdr.bfReserved1 = 0;
00729     bmpFileHdr.bfReserved2 = 0;
00730     bmpFileHdr.bfOffBits   = <span class="keyword">sizeof</span>(BITMAPFILEHEADER) + <span class="keyword">sizeof</span>(BITMAPINFOHEADER);
00731     <span class="keywordflow">if</span>( hasPaletteFlag )
00732         bmpFileHdr.bfOffBits += <span class="keyword">sizeof</span>(RGBQUAD)*256;
00733 
00734     bmpFile.<a class="code" href="classFile.html#a10">file_write</a>(&amp;bmpFileHdr, <span class="keyword">sizeof</span>(bmpFileHdr));
00735 
00736     <span class="comment">//------------ Write in the info header -----------//</span>
00737 
00738     BITMAPINFOHEADER bmpInfoHdr;
00739 
00740     bmpInfoHdr.biSize       = <span class="keyword">sizeof</span>(BITMAPINFOHEADER);
00741     bmpInfoHdr.biWidth      = buf_des.dwWidth;
00742     bmpInfoHdr.biHeight       = buf_des.dwHeight;
00743     bmpInfoHdr.biPlanes       = 1;
00744     bmpInfoHdr.biBitCount     = 24;
00745     bmpInfoHdr.biCompression   = BI_RGB;
00746     bmpInfoHdr.biSizeImage     = bmpInfoHdr.biWidth * bmpInfoHdr.biHeight * bmpInfoHdr.biBitCount / 8;
00747     bmpInfoHdr.biXPelsPerMeter = 0;
00748     bmpInfoHdr.biYPelsPerMeter = 0;
00749     bmpInfoHdr.biClrUsed    = 0;
00750     bmpInfoHdr.biClrImportant  = 0;
00751 
00752     bmpFile.<a class="code" href="classFile.html#a10">file_write</a>(&amp;bmpInfoHdr, <span class="keyword">sizeof</span>(bmpInfoHdr));
00753 
00754     <span class="comment">//------------ write the color table -----------//</span>
00755 
00756     <span class="keywordflow">if</span>( hasPaletteFlag ) {
00757         LPDIRECTDRAWPALETTE ddPalettePtr;             <span class="comment">// get the direct draw surface's palette</span>
00758         dd_buf-&gt;GetPalette(&amp;ddPalettePtr);
00759 
00760         PALETTEENTRY *palEntries = (PALETTEENTRY*) <a class="code" href="ALL_8H.html#a5">mem_add</a>( <span class="keyword">sizeof</span>(PALETTEENTRY)*256 );
00761         ddPalettePtr-&gt;GetEntries(0, 0, 256, palEntries);
00762 
00763         <span class="comment">// allocate a color table with 256 entries</span>
00764         RGBQUAD *colorTable = (RGBQUAD*) <a class="code" href="ALL_8H.html#a5">mem_add</a>( <span class="keyword">sizeof</span>(RGBQUAD)*256 );
00765 
00766         <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i=0 ; i&lt;256 ; i++ ) {
00767             colorTable[i].rgbBlue  = palEntries[i].peBlue;
00768             colorTable[i].rgbGreen = palEntries[i].peGreen;
00769             colorTable[i].rgbRed   = palEntries[i].peRed;
00770             colorTable[i].rgbReserved = 0;
00771         }
00772 
00773         bmpFile.<a class="code" href="classFile.html#a10">file_write</a>(colorTable, <span class="keyword">sizeof</span>(RGBQUAD)*256);
00774 
00775         <a class="code" href="ALL_8H.html#a8">mem_del</a>(palEntries);
00776         <a class="code" href="ALL_8H.html#a8">mem_del</a>(colorTable);
00777     }
00778 
00779     <span class="comment">//----------- write the bitmap ----------//</span>
00780 
00781     <span class="keywordflow">if</span>( bmpInfoHdr.biBitCount == 8 ) {
00782         <span class="keywordflow">for</span>( <span class="keywordtype">int</span> y=buf_height()-1 ; y&gt;=0 ; y-- )      <span class="comment">// write in reversed order as DIB's vertical order is reversed</span>
00783             bmpFile.<a class="code" href="classFile.html#a10">file_write</a>(buf_ptr(0,y), buf_width());
00784     }
00785     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( bmpInfoHdr.biBitCount == 24 ) {
00786         <span class="keywordtype">int</span> lineBufferSize = <span class="keyword">sizeof</span>(RGBColor) * bmpInfoHdr.biWidth;
00787         <a class="code" href="structRGBColor.html">RGBColor</a> *lineBuffer = (<a class="code" href="structRGBColor.html">RGBColor</a> *)<a class="code" href="ALL_8H.html#a5">mem_add</a>( lineBufferSize );
00788         <span class="keywordflow">for</span>( <span class="keywordtype">int</span> y = buf_height()-1; y&gt;=0 ; --y ) {
00789             <span class="keyword">register</span> <span class="keywordtype">short</span> *pixelPtr = buf_ptr( 0, y );
00790             <span class="keyword">register</span> <a class="code" href="structRGBColor.html">RGBColor</a> *lineBufPtr = lineBuffer;
00791             <span class="keywordflow">for</span>( <span class="keywordtype">int</span> x = buf_width()-1; x &gt;= 0; --x, ++pixelPtr, ++lineBufPtr) {
00792                 vga.decode_pixel( *pixelPtr, lineBufPtr );
00793                 <span class="keywordflow">if</span>(lineBufPtr-&gt;<a class="code" href="structRGBColor.html#m2">blue</a>&gt;=0xf8)                <span class="comment">// to make the printing output clearer</span>
00794                     lineBufPtr-&gt;<a class="code" href="structRGBColor.html#m2">blue</a>=0xff;                  <span class="comment">// chwg0410</span>
00795                 <span class="keywordflow">if</span>(lineBufPtr-&gt;<a class="code" href="structRGBColor.html#m1">green</a>&gt;=0xf8)               <span class="comment">// to make the printing output clearer</span>
00796                     lineBufPtr-&gt;<a class="code" href="structRGBColor.html#m1">green</a>=0xff;                 <span class="comment">// chwg0410</span>
00797                 <span class="keywordflow">if</span>(lineBufPtr-&gt;<a class="code" href="structRGBColor.html#m0">red</a>&gt;=0xf8)                 <span class="comment">// to make the printing output clearer</span>
00798                     lineBufPtr-&gt;<a class="code" href="structRGBColor.html#m0">red</a>=0xff;                   <span class="comment">// chwg0410</span>
00799                 <span class="comment">// exchange Red and blue</span>
00800                 BYTE r = lineBufPtr-&gt;<a class="code" href="structRGBColor.html#m0">red</a>;
00801                 lineBufPtr-&gt;<a class="code" href="structRGBColor.html#m0">red</a> = lineBufPtr-&gt;<a class="code" href="structRGBColor.html#m2">blue</a>;
00802                 lineBufPtr-&gt;<a class="code" href="structRGBColor.html#m2">blue</a> = r;
00803             }
00804             bmpFile.<a class="code" href="classFile.html#a10">file_write</a>(lineBuffer, lineBufferSize );
00805         }
00806         <a class="code" href="ALL_8H.html#a8">mem_del</a>(lineBuffer);
00807     }
00808     <span class="keywordflow">else</span> {
00809         <a class="code" href="ALL_8H.html#a1">err_here</a>();
00810     }
00811 
00812     <span class="comment">//------------ close the file -----------//</span>
00813 
00814     bmpFile.<a class="code" href="classFile.html#a5">file_close</a>();
00815 
00816     <span class="keywordflow">return</span> 1;
00817 }
00818 
00819 <span class="comment">//------------ End of function VgaBuf::write_bmp_file --------------//</span>
00820 
00821 <span class="comment">//------------ Begin of function VgaBuf::write_bmp_file_area --------------//</span>
<a name="l00829"></a><a class="code" href="classVgaBuf.html#a26">00829</a> <span class="comment">int VgaBuf::write_bmp_file_area(char* fileName, int x1, int y1, int x2, int y2) {</span>
00830     <a class="code" href="classFile.html">File</a>       bmpFile;
00831     BITMAPINFO*  bmpInfoPtr = <a class="code" href="OHELP_8H.html#a0">NULL</a>;
00832     <span class="keywordtype">char</span>*      bitmapPtr = <a class="code" href="OHELP_8H.html#a0">NULL</a>;
00833 
00834     <span class="keywordtype">int</span>        hasPaletteFlag = 0;
00835     <span class="keywordtype">int</span>        bytePerPixel = <span class="keyword">sizeof</span>(RGBColor);
00836 
00837     bmpFile.<a class="code" href="classFile.html#a3">file_create</a>(fileName, 1, 0);            <span class="comment">// 1-handle error, 0-disable variable file size</span>
00838 
00839     <span class="comment">//------------ Write the file header ------------//</span>
00840 
00841     BITMAPFILEHEADER bmpFileHdr;
00842 
00843     bmpFileHdr.bfType    = 0x4D42;                  <span class="comment">// set the type to "BM"</span>
00844     <span class="comment">// buf_size();</span>
00845     bmpFileHdr.bfSize    = (x2-x1+1)*(y2-y1+1)*bytePerPixel;
00846     bmpFileHdr.bfReserved1 = 0;
00847     bmpFileHdr.bfReserved2 = 0;
00848     bmpFileHdr.bfOffBits   = <span class="keyword">sizeof</span>(BITMAPFILEHEADER) + <span class="keyword">sizeof</span>(BITMAPINFOHEADER);
00849     <span class="keywordflow">if</span>( hasPaletteFlag )
00850         bmpFileHdr.bfOffBits += <span class="keyword">sizeof</span>(RGBQUAD)*256;
00851 
00852     bmpFile.<a class="code" href="classFile.html#a10">file_write</a>(&amp;bmpFileHdr, <span class="keyword">sizeof</span>(bmpFileHdr));
00853 
00854     <span class="comment">//------------ Write in the info header -----------//</span>
00855 
00856     BITMAPINFOHEADER bmpInfoHdr;
00857 
00858     bmpInfoHdr.biSize       = <span class="keyword">sizeof</span>(BITMAPINFOHEADER);
00859     bmpInfoHdr.biWidth      = (x2-x1+1);            <span class="comment">// buf_des.dwWidth;</span>
00860     bmpInfoHdr.biHeight       = (y2-y1+1);          <span class="comment">// buf_des.dwHeight;</span>
00861     bmpInfoHdr.biPlanes       = 1;
00862     bmpInfoHdr.biBitCount     = bytePerPixel*8;
00863     bmpInfoHdr.biCompression   = BI_RGB;
00864     bmpInfoHdr.biSizeImage     = bmpInfoHdr.biWidth * bmpInfoHdr.biHeight * bmpInfoHdr.biBitCount / 8;
00865     bmpInfoHdr.biXPelsPerMeter = 0;
00866     bmpInfoHdr.biYPelsPerMeter = 0;
00867     bmpInfoHdr.biClrUsed    = 0;
00868     bmpInfoHdr.biClrImportant  = 0;
00869 
00870     bmpFile.<a class="code" href="classFile.html#a10">file_write</a>(&amp;bmpInfoHdr, <span class="keyword">sizeof</span>(bmpInfoHdr));
00871 
00872     <span class="comment">//------------ write the color table -----------//</span>
00873 
00874     <span class="keywordflow">if</span>( hasPaletteFlag ) {
00875         LPDIRECTDRAWPALETTE ddPalettePtr;             <span class="comment">// get the direct draw surface's palette</span>
00876         dd_buf-&gt;GetPalette(&amp;ddPalettePtr);
00877 
00878         PALETTEENTRY *palEntries = (PALETTEENTRY*) <a class="code" href="ALL_8H.html#a5">mem_add</a>( <span class="keyword">sizeof</span>(PALETTEENTRY)*256 );
00879         ddPalettePtr-&gt;GetEntries(0, 0, 256, palEntries);
00880 
00881         <span class="comment">// allocate a color table with 256 entries</span>
00882         RGBQUAD *colorTable = (RGBQUAD*) <a class="code" href="ALL_8H.html#a5">mem_add</a>( <span class="keyword">sizeof</span>(RGBQUAD)*256 );
00883 
00884         <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i=0 ; i&lt;256 ; i++ ) {
00885             colorTable[i].rgbBlue  = palEntries[i].peBlue;
00886             colorTable[i].rgbGreen = palEntries[i].peGreen;
00887             colorTable[i].rgbRed   = palEntries[i].peRed;
00888             colorTable[i].rgbReserved = 0;
00889         }
00890 
00891         bmpFile.<a class="code" href="classFile.html#a10">file_write</a>(colorTable, <span class="keyword">sizeof</span>(RGBQUAD)*256);
00892 
00893         <a class="code" href="ALL_8H.html#a8">mem_del</a>(palEntries);
00894         <a class="code" href="ALL_8H.html#a8">mem_del</a>(colorTable);
00895     }
00896 
00897     <span class="comment">//----------- write the bitmap ----------//</span>
00898 
00899     <span class="keywordflow">if</span>( bmpInfoHdr.biBitCount == 8 ) {
00900         <span class="keywordflow">for</span>( <span class="keywordtype">int</span> y=buf_height()-1 ; y&gt;=0 ; y-- )      <span class="comment">// write in reversed order as DIB's vertical order is reversed</span>
00901             bmpFile.<a class="code" href="classFile.html#a10">file_write</a>(buf_ptr(0,y), buf_width());
00902     }
00903     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( bmpInfoHdr.biBitCount == 24 ) {
00904         <span class="keywordtype">int</span> lineBufferSize = <span class="keyword">sizeof</span>(RGBColor) * bmpInfoHdr.biWidth;
00905         <a class="code" href="structRGBColor.html">RGBColor</a> *lineBuffer = (<a class="code" href="structRGBColor.html">RGBColor</a> *)<a class="code" href="ALL_8H.html#a5">mem_add</a>( lineBufferSize );
00906         <span class="keywordflow">for</span>( <span class="keywordtype">int</span> y = y2; y&gt;=y1 ; --y ) {
00907             <span class="keywordtype">short</span> *pixelPtr = buf_ptr( x1, y );
00908             <a class="code" href="structRGBColor.html">RGBColor</a> *lineBufPtr = lineBuffer;
00909             <span class="keywordflow">for</span>( <span class="keywordtype">int</span> x = x1; x &lt;= x2; ++x, ++pixelPtr, ++lineBufPtr) {
00910                 vga.decode_pixel( *pixelPtr, lineBufPtr );
00911                 <span class="keywordflow">if</span>(lineBufPtr-&gt;<a class="code" href="structRGBColor.html#m2">blue</a>&gt;=0xf8)                <span class="comment">// to make the printing output clearer</span>
00912                     lineBufPtr-&gt;<a class="code" href="structRGBColor.html#m2">blue</a>=0xff;                  <span class="comment">// chwg0410</span>
00913                 <span class="keywordflow">if</span>(lineBufPtr-&gt;<a class="code" href="structRGBColor.html#m1">green</a>&gt;=0xf8)               <span class="comment">// to make the printing output clearer</span>
00914                     lineBufPtr-&gt;<a class="code" href="structRGBColor.html#m1">green</a>=0xff;                 <span class="comment">// chwg0410</span>
00915                 <span class="keywordflow">if</span>(lineBufPtr-&gt;<a class="code" href="structRGBColor.html#m0">red</a>&gt;=0xf8)                 <span class="comment">// to make the printing output clearer</span>
00916                     lineBufPtr-&gt;<a class="code" href="structRGBColor.html#m0">red</a>=0xff;                   <span class="comment">// chwg0410</span>
00917                 <span class="comment">// exchange Red and blue</span>
00918                 BYTE r = lineBufPtr-&gt;<a class="code" href="structRGBColor.html#m0">red</a>;
00919                 lineBufPtr-&gt;<a class="code" href="structRGBColor.html#m0">red</a> = lineBufPtr-&gt;<a class="code" href="structRGBColor.html#m2">blue</a>;
00920                 lineBufPtr-&gt;<a class="code" href="structRGBColor.html#m2">blue</a> = r;
00921             }
00922             bmpFile.<a class="code" href="classFile.html#a10">file_write</a>(lineBuffer, lineBufferSize );
00923         }
00924         <a class="code" href="ALL_8H.html#a8">mem_del</a>(lineBuffer);
00925     }
00926     <span class="keywordflow">else</span> {
00927         <a class="code" href="ALL_8H.html#a1">err_here</a>();
00928     }
00929 
00930     <span class="comment">//------------ close the file -----------//</span>
00931 
00932     bmpFile.<a class="code" href="classFile.html#a5">file_close</a>();
00933 
00934     <span class="keywordflow">return</span> 1;
00935 }
00936 
00937 <span class="comment">//------------ End of function VgaBuf::write_bmp_file --------------//</span>
00938 
00939 <span class="comment">//---------- Begin of function VgaBuf::put_large_bitmap ---------//</span>
00957 <span class="comment"></span>
<a name="l00958"></a><a class="code" href="classVgaBuf.html#a55">00958</a> <span class="keywordtype">void</span> <a class="code" href="classVgaBuf.html#a55">VgaBuf::put_large_bitmap</a>(<span class="keywordtype">int</span> x1, <span class="keywordtype">int</span> y1, <a class="code" href="classFile.html">File</a>* filePtr, <span class="keywordtype">short</span> *colorRemapTable) {
00959     <span class="keywordflow">if</span>( filePtr == <a class="code" href="OHELP_8H.html#a0">NULL</a> )
00960         <span class="keywordflow">return</span>;
00961 
00962     <span class="keywordflow">if</span>( !colorRemapTable )
00963         colorRemapTable = <a class="code" href="classVgaBuf.html#p7">default_remap_table</a>;
00964 
00965     <span class="keywordtype">int</span> pictWidth = filePtr-&gt;<a class="code" href="classFile.html#a11">file_get_short</a>();
00966     <span class="keywordtype">int</span> hasPalette=0;
00967 
00968     <span class="comment">//------ read in bitmap and display it --------//</span>
00969 
00970     <span class="keywordtype">int</span> pictHeight = filePtr-&gt;<a class="code" href="classFile.html#a11">file_get_short</a>();
00971     <span class="keywordtype">int</span> x2 = x1 + pictWidth  - 1;
00972     <span class="keywordtype">int</span> y2 = y1 + pictHeight - 1;
00973 
00974     <span class="keywordtype">long</span> pictSize = (long) pictWidth * pictHeight;
00975 
00976     <a class="code" href="ALL_8H.html#a0">err_when</a>( x1&gt;x2 || y1&gt;y2 || x1&lt;0 || y1&lt;0 || x2&gt;=<a class="code" href="OVGA_8H.html#a0">VGA_WIDTH</a> || y2&gt;=<a class="code" href="OVGA_8H.html#a1">VGA_HEIGHT</a> );
00977 
00978     <span class="comment">//---- if pict size less than 64K, read in the picture in one step ----//</span>
00979 
00980     <span class="keywordflow">if</span>( <a class="code" href="classBitmap.html#a7">Bitmap::size</a>(pictWidth, pictHeight) &lt;= <a class="code" href="Osys_8h.html#a40a2">COMMON_DATA_BUF_SIZE</a> ) {
00981         ((<a class="code" href="classBitmap.html">Bitmap</a> *)sys.common_data_buf)-&gt;init(pictWidth, pictHeight);
00982 
00983         filePtr-&gt;<a class="code" href="classFile.html#a9">file_read</a>( ((<a class="code" href="classBitmap.html">Bitmap</a> *)sys.common_data_buf)-&gt;bitmap, pictSize );
00984 
00985         <span class="keywordflow">if</span>( is_front )
00986             mouse.hide_area( x1,y1,x2,y2 );             <span class="comment">// if the mouse cursor is in that area, hide it</span>
00987 
00988         <a class="code" href="classVgaBuf.html#a62">put_bitmap_remap_fast</a>( x1, y1, (<span class="keywordtype">char</span> *)sys.common_data_buf, colorRemapTable );
00989 
00990         <span class="keywordflow">if</span>( is_front )
00991             mouse.show_area();
00992     }
00993     <span class="keywordflow">else</span> {                                          <span class="comment">//----- if the picture size &gt; 64K, read in line by line -----//</span>
00994         <span class="comment">// max. no. of lines can be in the buffer</span>
00995         <span class="keywordtype">int</span> bufferLine = (<a class="code" href="Osys_8h.html#a40a2">COMMON_DATA_BUF_SIZE</a> - 2*<span class="keyword">sizeof</span>(short) )/ pictWidth;
00996         <span class="keywordtype">int</span> ty=y1+bufferLine-1;
00997 
00998         <span class="keywordflow">if</span>( ty&gt; y2 )
00999             ty=y2;
01000 
01001         <span class="keywordflow">while</span>( y1&lt;=y2 ) {
01002             ((<a class="code" href="classBitmap.html">Bitmap</a> *)sys.common_data_buf)-&gt;init( pictWidth, (ty-y1+1) );
01003             filePtr-&gt;<a class="code" href="classFile.html#a9">file_read</a>( ((<a class="code" href="classBitmap.html">Bitmap</a> *)sys.common_data_buf)-&gt;bitmap, (<span class="keywordtype">unsigned</span>)pictWidth * (ty-y1+1) );
01004 
01005             <span class="keywordflow">if</span>( is_front )
01006                 mouse.hide_area( x1,y1,x2,ty );           <span class="comment">// if the mouse cursor is in that area, hide it</span>
01007 
01008             <a class="code" href="classVgaBuf.html#a62">put_bitmap_remap_fast</a>( x1, y1, sys.common_data_buf, colorRemapTable );
01009 
01010             <span class="keywordflow">if</span>( is_front )
01011                 mouse.show_area();
01012 
01013             y1 += bufferLine;
01014 
01015             <span class="keywordflow">if</span>( (ty+=bufferLine) &gt; y2 )
01016                 ty=y2;
01017         }
01018     }
01019 }
01020 
01021 <span class="comment">//----------- End of function VgaBuf::put_large_bitmap --------//</span>
01022 
01023 <span class="comment">//---------- Begin of function VgaBuf::put_large_bitmapW ---------//</span>
01041 <span class="comment"></span>
<a name="l01042"></a><a class="code" href="classVgaBuf.html#a56">01042</a> <span class="keywordtype">void</span> <a class="code" href="classVgaBuf.html#a56">VgaBuf::put_large_bitmapW</a>(<span class="keywordtype">int</span> x1, <span class="keywordtype">int</span> y1, <a class="code" href="classFile.html">File</a>* filePtr) {
01043     <span class="keywordflow">if</span>( filePtr == <a class="code" href="OHELP_8H.html#a0">NULL</a> )
01044         <span class="keywordflow">return</span>;
01045 
01046     <span class="keywordtype">int</span> pictWidth = filePtr-&gt;<a class="code" href="classFile.html#a11">file_get_short</a>();
01047 
01048     <span class="comment">//------ read in bitmap and display it --------//</span>
01049 
01050     <span class="keywordtype">int</span> pictHeight = filePtr-&gt;<a class="code" href="classFile.html#a11">file_get_short</a>();
01051     <span class="keywordtype">int</span> x2 = x1 + pictWidth  - 1;
01052     <span class="keywordtype">int</span> y2 = y1 + pictHeight - 1;
01053 
01054     <span class="keywordtype">long</span> pictSize = (long) pictWidth * pictHeight * <span class="keyword">sizeof</span>(short);
01055 
01056     <a class="code" href="ALL_8H.html#a0">err_when</a>( x1&gt;x2 || y1&gt;y2 || x1&lt;0 || y1&lt;0 || x2&gt;=<a class="code" href="OVGA_8H.html#a0">VGA_WIDTH</a> || y2&gt;=<a class="code" href="OVGA_8H.html#a1">VGA_HEIGHT</a> );
01057 
01058     <span class="comment">//---- if pict size less than 64K, read in the picture in one step ----//</span>
01059 
01060     <span class="keywordflow">if</span>( <a class="code" href="classBitmapW.html#a7">BitmapW::size</a>(pictWidth, pictHeight) &lt;= <a class="code" href="Osys_8h.html#a40a2">COMMON_DATA_BUF_SIZE</a> ) {
01061         ((<a class="code" href="classBitmapW.html">BitmapW</a> *)sys.common_data_buf)-&gt;init(pictWidth, pictHeight);
01062 
01063         filePtr-&gt;<a class="code" href="classFile.html#a9">file_read</a>( ((<a class="code" href="classBitmapW.html">BitmapW</a> *)sys.common_data_buf)-&gt;bitmap, pictSize );
01064 
01065         <span class="keywordflow">if</span>( is_front )
01066             mouse.hide_area( x1,y1,x2,y2 );             <span class="comment">// if the mouse cursor is in that area, hide it</span>
01067 
01068         <a class="code" href="classVgaBuf.html#a85">put_bitmapW</a>( x1, y1, (<span class="keywordtype">short</span> *)sys.common_data_buf );
01069 
01070         <span class="keywordflow">if</span>( is_front )
01071             mouse.show_area();
01072     }
01073     <span class="keywordflow">else</span> {                                          <span class="comment">//----- if the picture size &gt; 64K, read in line by line -----//</span>
01074         <span class="comment">// max. no. of lines can be in the buffer</span>
01075         <span class="keywordtype">int</span> bufferLine = (<a class="code" href="Osys_8h.html#a40a2">COMMON_DATA_BUF_SIZE</a> - 2*<span class="keyword">sizeof</span>(short) )/ pictWidth / <span class="keyword">sizeof</span>(short);
01076         <span class="keywordtype">int</span> ty=y1+bufferLine-1;
01077 
01078         <span class="keywordflow">if</span>( ty&gt; y2 )
01079             ty=y2;
01080 
01081         <span class="keywordflow">while</span>( y1&lt;=y2 ) {
01082             ((<a class="code" href="classBitmapW.html">BitmapW</a> *)sys.common_data_buf)-&gt;init( pictWidth, (ty-y1+1) );
01083             filePtr-&gt;<a class="code" href="classFile.html#a9">file_read</a>( ((<a class="code" href="classBitmapW.html">BitmapW</a> *)sys.common_data_buf)-&gt;bitmap, (<span class="keywordtype">unsigned</span>)pictWidth * (ty-y1+1) * <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>) );
01084 
01085             <span class="keywordflow">if</span>( is_front )
01086                 mouse.hide_area( x1,y1,x2,ty );           <span class="comment">// if the mouse cursor is in that area, hide it</span>
01087 
01088             <a class="code" href="classVgaBuf.html#a85">put_bitmapW</a>( x1, y1, (<span class="keywordtype">short</span> *)sys.common_data_buf);
01089 
01090             <span class="keywordflow">if</span>( is_front )
01091                 mouse.show_area();
01092 
01093             y1 += bufferLine;
01094 
01095             <span class="keywordflow">if</span>( (ty+=bufferLine) &gt; y2 )
01096                 ty=y2;
01097         }
01098     }
01099 }
01100 
01101 <span class="comment">//----------- End of function VgaBuf::put_large_bitmapW --------//</span>
01102 
01103 <span class="comment">//----------- Begin of function VgaBuf::convert_gray ----------//</span>
<a name="l01107"></a><a class="code" href="classVgaBuf.html#a49">01107</a> <span class="comment">void VgaBuf::convert_gray(int x1, int y1, int x2, int y2) {</span>
01108     <span class="comment">// remap_bar(x1, y1, x2, y2, vga.gray_remap_table);</span>
01109 }
01110 
01111 <span class="comment">//--------- End of function VgaBuf::convert_gray -----------//</span>
</pre></div><hr><address style="align: right;"><small>Generated on Fri Aug 23 01:38:34 2002 for VirtualU by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.17 </small></address>
</body>
</html>
