<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>NEWMATNL.CPP Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.17 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>NEWMATNL.CPP</h1><a href="NEWMATNL_8CPP.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">//Owner: Fred</span>
00002 <span class="comment">//$$ newmatnl.cpp         Non-linear optimisation</span>
00003 
00004 <span class="comment">// Copyright (C) 1993,4,5,6: R B Davies</span>
00005 
<a name="l00006"></a><a class="code" href="NEWMATNL_8CPP.html#a0">00006</a> <span class="preprocessor">#define WANT_MATH</span>
<a name="l00007"></a><a class="code" href="NEWMATNL_8CPP.html#a1">00007</a> <span class="preprocessor"></span><span class="preprocessor">#define WANT_STREAM</span>
00008 <span class="preprocessor"></span>
00009 <span class="preprocessor">#include "newmatap.h"</span>
00010 <span class="preprocessor">#include "newmatnl.h"</span>
00011 
00012 <span class="preprocessor">#ifdef use_namespace</span>
00013 <span class="preprocessor"></span><span class="keyword">namespace </span>NEWMAT {
00014 <span class="preprocessor">#endif</span>
00015 <span class="preprocessor"></span>
<a name="l00016"></a><a class="code" href="classFindMaximum2.html#a0">00016</a>     <span class="keywordtype">void</span> <a class="code" href="classFindMaximum2.html#a0">FindMaximum2::Fit</a>(ColumnVector&amp; Theta, <span class="keywordtype">int</span> n_it) {
00017         <a class="code" href="classTracer.html">Tracer</a> tr(<span class="stringliteral">"FindMaximum2::Fit"</span>);
00018         <span class="keyword">enum</span> <a class="code" href="OVIDEO_8H.html#a0">State</a> {
00019             Start, Restart, Continue, Interpolate, Extrapolate,
00020             Fail, Convergence
00021         };
00022         <a class="code" href="OVIDEO_8H.html#a0">State</a> TheState = Start;
00023         <a class="code" href="namespaceRBD__COMMON.html#a0">Real</a> z,w,x,x2,g,l1,l2,l3,d1,d2,d3;
00024         ColumnVector Theta1, Theta2, Theta3;
00025         <span class="keywordtype">int</span> np = Theta.Nrows();
00026         ColumnVector H1(np), H3, HP(np), K, K1(np);
00027         <span class="keywordtype">bool</span> oorg, conv;
00028         <span class="keywordtype">int</span> counter = 0;
00029         Theta1 = Theta; HP = 0.0; g = 0.0;
00030 
00031         <span class="comment">// This is really a set of gotos and labels, but they don't work</span>
00032         <span class="comment">// correctly in AT&amp;T C++ and Sun 4.01 C++.</span>
00033 
00034         <span class="keywordflow">for</span>(;;) {
00035             <span class="keywordflow">switch</span> (TheState) {
00036             <span class="keywordflow">case</span> Start:
00037                 tr.<a class="code" href="classTracer.html#a2">ReName</a>(<span class="stringliteral">"FindMaximum2::Fit/Start"</span>);
00038                 Value(Theta1, <span class="keyword">true</span>, l1, oorg);
00039                 <span class="keywordflow">if</span> (oorg) Throw(ProgramException(<span class="stringliteral">"invalid starting value\n"</span>));
00040 
00041             <span class="keywordflow">case</span> Restart:
00042                 tr.<a class="code" href="classTracer.html#a2">ReName</a>(<span class="stringliteral">"FindMaximum2::Fit/ReStart"</span>);
00043                 conv = NextPoint(H1, d1);
00044                 <span class="keywordflow">if</span> (conv) { TheState = Convergence; <span class="keywordflow">break</span>; }
00045                 <span class="keywordflow">if</span> (counter++ &gt; n_it) { TheState = Fail; <span class="keywordflow">break</span>; }
00046 
00047                 z = 1.0 / sqrt(d1);
00048                 H3 = H1 * z; K = (H3 - HP) * g; HP = H3;
00049                 g = 0.0;                                <span class="comment">// de-activate to use curved projection</span>
00050                 <span class="keywordflow">if</span> (g==0.0) K1 = 0.0; <span class="keywordflow">else</span> K1 = K * 0.2 + K1 * 0.6;
00051                 <span class="comment">// (K - K1) * alpha + K1 * (1 - alpha)</span>
00052                 <span class="comment">//     = K * alpha + K1 * (1 - 2 * alpha)</span>
00053                 K = K1 * d1; g = z;
00054 
00055             <span class="keywordflow">case</span> Continue:
00056                 tr.<a class="code" href="classTracer.html#a2">ReName</a>(<span class="stringliteral">"FindMaximum2::Fit/Continue"</span>);
00057                 Theta2 = Theta1 + H1 + K;
00058                 Value(Theta2, <span class="keyword">false</span>, l2, oorg);
00059                 <span class="keywordflow">if</span> (counter++ &gt; n_it) { TheState = Fail; <span class="keywordflow">break</span>; }
00060                 <span class="keywordflow">if</span> (oorg) {
00061                     H1 *= 0.5; K *= 0.25; d1 *= 0.5; g *= 2.0;
00062                     TheState =  Continue; <span class="keywordflow">break</span>;
00063                 }
00064                 d2 = LastDerivative(H1 + K * 2.0);
00065 
00066             <span class="keywordflow">case</span> Interpolate:
00067                 tr.<a class="code" href="classTracer.html#a2">ReName</a>(<span class="stringliteral">"FindMaximum2::Fit/Interpolate"</span>);
00068                 z = d1 + d2 - 3.0 * (l2 - l1);
00069                 w = z * z - d1 * d2;
00070                 <span class="keywordflow">if</span> (w &lt; 0.0) { TheState = Extrapolate; <span class="keywordflow">break</span>; }
00071                 w = z + sqrt(w);
00072                 <span class="keywordflow">if</span> (1.5 * w + d1 &lt; 0.0)
00073                 { TheState = Extrapolate; <span class="keywordflow">break</span>; }
00074                 <span class="keywordflow">if</span> (d2 &gt; 0.0 &amp;&amp; l2 &gt; l1 &amp;&amp; w &gt; 0.0)
00075                 { TheState = Extrapolate; <span class="keywordflow">break</span>; }
00076                 x = d1 / (w + d1); x2 = x * x; g /= x;
00077                 Theta3 = Theta1 + H1 * x + K * x2;
00078                 Value(Theta3, <span class="keyword">true</span>, l3, oorg);
00079                 <span class="keywordflow">if</span> (counter++ &gt; n_it) { TheState = Fail; <span class="keywordflow">break</span>; }
00080                 <span class="keywordflow">if</span> (oorg) {
00081                     <span class="keywordflow">if</span> (x &lt;= 1.0)
00082                     { x *= 0.5; x2 = x*x; g *= 2.0; d1 *= x; H1 *= x; K *= x2; }
00083                     <span class="keywordflow">else</span> {
00084                         x = 0.5 * (x-1.0); x2 = x*x; Theta1 = Theta2;
00085                         H1 = (H1 + K * 2.0) * x;
00086                         K *= x2; g = 0.0; d1 = x * d2; l1 = l2;
00087                     }
00088                     TheState = Continue; <span class="keywordflow">break</span>;
00089                 }
00090 
00091                 <span class="keywordflow">if</span> (l3 &gt;= l1 &amp;&amp; l3 &gt;= l2)
00092                 { Theta1 = Theta3; l1 = l3; TheState =  Restart; <span class="keywordflow">break</span>; }
00093 
00094                 d3 = LastDerivative(H1 + K * 2.0);
00095                 <span class="keywordflow">if</span> (l1 &gt; l2)
00096                 { H1 *= x; K *= x2; Theta2 = Theta3; d1 *= x; d2 = d3*x; }
00097                 <span class="keywordflow">else</span> {
00098                     Theta1 = Theta2; Theta2 = Theta3;
00099                     x -= 1.0; x2 = x*x; g = 0.0; H1 = (H1 + K * 2.0) * x;
00100                     K *= x2; l1 = l2; l2 = l3; d1 = x*d2; d2 = x*d3;
00101                     <span class="keywordflow">if</span> (d1 &lt;= 0.0) { TheState = Start; <span class="keywordflow">break</span>; }
00102                 }
00103                 TheState =  Interpolate; <span class="keywordflow">break</span>;
00104 
00105             <span class="keywordflow">case</span> Extrapolate:
00106                 tr.<a class="code" href="classTracer.html#a2">ReName</a>(<span class="stringliteral">"FindMaximum2::Fit/Extrapolate"</span>);
00107                 Theta1 = Theta2; g = 0.0; K *= 4.0; H1 = (H1 * 2.0 + K);
00108                 d1 = 2.0 * d2; l1 = l2;
00109                 TheState = Continue; <span class="keywordflow">break</span>;
00110 
00111             <span class="keywordflow">case</span> Fail:
00112                 Throw(ConvergenceException(Theta));
00113 
00114             <span class="keywordflow">case</span> Convergence:
00115                 Theta = Theta1; <span class="keywordflow">return</span>;
00116             }
00117         }
00118     }
00119 
00120     <span class="keywordtype">void</span> NonLinearLeastSquares::Value
00121     (<span class="keyword">const</span> ColumnVector&amp; Parameters, <span class="keywordtype">bool</span>, <a class="code" href="namespaceRBD__COMMON.html#a0">Real</a>&amp; v, <span class="keywordtype">bool</span>&amp; oorg) {
00122         <a class="code" href="classTracer.html">Tracer</a> tr(<span class="stringliteral">"NonLinearLeastSquares::Value"</span>);
00123         Y.ReSize(n_obs); X.ReSize(n_obs,n_param);
00124         <span class="comment">// put the fitted values in Y, the derivatives in X.</span>
00125         Pred.Set(Parameters);
00126         <span class="keywordflow">if</span> (!Pred.IsValid()) { oorg=<span class="keyword">true</span>; <span class="keywordflow">return</span>; }
00127         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;=n_obs; i++) {
00128             Y(i) = Pred(i);
00129             X.Row(i) = Pred.Derivatives();
00130         }
00131         <span class="keywordflow">if</span> (!Pred.IsValid()) {                        <span class="comment">// check afterwards as well</span>
00132             oorg=<span class="keyword">true</span>; <span class="keywordflow">return</span>;
00133         }
00134         Y = *DataPointer - Y; <a class="code" href="namespaceRBD__COMMON.html#a0">Real</a> ssq = Y.SumSquare();
00135         errorvar =  ssq / (n_obs - n_param);
00136         cout &lt;&lt; <span class="stringliteral">"\n"</span> &lt;&lt; setw(15) &lt;&lt; setprecision(10) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; errorvar;
00137         Derivs = Y.t() * X;                           <span class="comment">// get the derivative and stash it</span>
00138         oorg = <span class="keyword">false</span>; v = -0.5 * ssq;
00139     }
00140 
00141     <span class="keywordtype">bool</span> NonLinearLeastSquares::NextPoint(ColumnVector&amp; Adj, <a class="code" href="namespaceRBD__COMMON.html#a0">Real</a>&amp; <a class="code" href="OTEST_8H.html#a0">test</a>) {
00142         <a class="code" href="classTracer.html">Tracer</a> tr(<span class="stringliteral">"NonLinearLeastSquares::NextPoint"</span>);
00143         <a class="code" href="HHOLDER_8CPP.html#a14">QRZ</a>(X, U); <a class="code" href="HHOLDER_8CPP.html#a14">QRZ</a>(X, Y, M);                      <span class="comment">// do the QR decomposition</span>
00144         <a class="code" href="OTEST_8H.html#a0">test</a> = M.SumSquare();
00145         cout &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; setw(15) &lt;&lt; setprecision(10)
00146              &lt;&lt; <a class="code" href="OTEST_8H.html#a0">test</a> &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; Y.SumSquare() / (n_obs - n_param);
00147         Adj = U.i() * M;
00148         <span class="keywordflow">if</span> (<a class="code" href="OTEST_8H.html#a0">test</a> &lt; errorvar * criterion) <span class="keywordflow">return</span> <span class="keyword">true</span>;
00149         <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;
00150     }
00151 
00152     <a class="code" href="namespaceRBD__COMMON.html#a0">Real</a> NonLinearLeastSquares::LastDerivative(<span class="keyword">const</span> ColumnVector&amp; H)
00153     { <span class="keywordflow">return</span> (Derivs * H).AsScalar(); }
00154 
<a name="l00155"></a><a class="code" href="classNonLinearLeastSquares.html#a1">00155</a>     <span class="keywordtype">void</span> <a class="code" href="classNonLinearLeastSquares.html#a1">NonLinearLeastSquares::Fit</a>(<span class="keyword">const</span> ColumnVector&amp; Data,
00156                                     ColumnVector&amp; Parameters) {
00157         <a class="code" href="classTracer.html">Tracer</a> tr(<span class="stringliteral">"NonLinearLeastSquares::Fit"</span>);
00158         n_param = Parameters.Nrows(); n_obs = Data.Nrows();
00159         DataPointer = &amp;Data;
00160         <a class="code" href="classFindMaximum2.html#a0">FindMaximum2::Fit</a>(Parameters, Lim);
00161         cout &lt;&lt; <span class="stringliteral">"\nConverged\n"</span>;
00162     }
00163 
00164     <span class="keywordtype">void</span> NonLinearLeastSquares::MakeCovariance() {
00165         <span class="keywordflow">if</span> (Covariance.Nrows()==0) {
00166             UpperTriangularMatrix UI = U.i();
00167             Covariance &lt;&lt; UI * UI.t() * errorvar;
00168             SE &lt;&lt; Covariance;                           <span class="comment">// get diagonals</span>
00169             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i&lt;=n_param; i++) SE(i) = sqrt(SE(i));
00170         }
00171     }
00172 
<a name="l00173"></a><a class="code" href="classNonLinearLeastSquares.html#a4">00173</a>     <span class="keywordtype">void</span> <a class="code" href="classNonLinearLeastSquares.html#a4">NonLinearLeastSquares::GetStandardErrors</a>(ColumnVector&amp; SEX)
00174     { MakeCovariance(); SEX = SE.AsColumn(); }
00175 
<a name="l00176"></a><a class="code" href="classNonLinearLeastSquares.html#a5">00176</a>     <span class="keywordtype">void</span> <a class="code" href="classNonLinearLeastSquares.html#a5">NonLinearLeastSquares::GetCorrelations</a>(SymmetricMatrix&amp; Corr)
00177     { MakeCovariance(); Corr &lt;&lt; SE.i() * Covariance * SE.i(); }
00178 
<a name="l00179"></a><a class="code" href="classNonLinearLeastSquares.html#a6">00179</a>     <span class="keywordtype">void</span> <a class="code" href="classNonLinearLeastSquares.html#a6">NonLinearLeastSquares::GetHatDiagonal</a>(DiagonalMatrix&amp; Hat)<span class="keyword"> const </span>{
00180         Hat.ReSize(n_obs);
00181         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i&lt;=n_obs; i++) Hat(i) = X.Row(i).SumSquare();
00182     }
00183 
00184     <span class="comment">// the MLE_D_FI routines</span>
00185 
00186     <span class="keywordtype">void</span> MLE_D_FI::Value
00187     (<span class="keyword">const</span> ColumnVector&amp; Parameters, <span class="keywordtype">bool</span> wg, <a class="code" href="namespaceRBD__COMMON.html#a0">Real</a>&amp; v, <span class="keywordtype">bool</span>&amp; oorg) {
00188         <a class="code" href="classTracer.html">Tracer</a> tr(<span class="stringliteral">"MLE_D_FI::Value"</span>);
00189         <span class="keywordflow">if</span> (!LL.IsValid(Parameters,wg)) { oorg=<span class="keyword">true</span>; <span class="keywordflow">return</span>; }
00190         v = LL.LogLikelihood();
00191         <span class="keywordflow">if</span> (!LL.IsValid()) {                          <span class="comment">// check validity again</span>
00192             oorg=<span class="keyword">true</span>; <span class="keywordflow">return</span>;
00193         }
00194         cout &lt;&lt; <span class="stringliteral">"\n"</span> &lt;&lt; setw(20) &lt;&lt; setprecision(10) &lt;&lt; v;
00195         oorg = <span class="keyword">false</span>;
00196         Derivs = LL.Derivatives();                    <span class="comment">// Get derivatives</span>
00197     }
00198 
00199     <span class="keywordtype">bool</span> MLE_D_FI::NextPoint(ColumnVector&amp; Adj, <a class="code" href="namespaceRBD__COMMON.html#a0">Real</a>&amp; <a class="code" href="OTEST_8H.html#a0">test</a>) {
00200         <a class="code" href="classTracer.html">Tracer</a> tr(<span class="stringliteral">"MLE_D_FI::NextPoint"</span>);
00201         SymmetricMatrix FI = LL.FI();
00202         LT = <a class="code" href="CHOLESKY_8CPP.html#a3">Cholesky</a>(FI);
00203         ColumnVector Adj1 = LT.i() * Derivs;
00204         Adj = LT.t().i() * Adj1;
00205         <a class="code" href="OTEST_8H.html#a0">test</a> = <a class="code" href="namespaceNEWMAT.html#a30">SumSquare</a>(Adj1);
00206         cout &lt;&lt; <span class="stringliteral">"   "</span> &lt;&lt; setw(20) &lt;&lt; setprecision(10) &lt;&lt; <a class="code" href="OTEST_8H.html#a0">test</a>;
00207         <span class="keywordflow">return</span> (<a class="code" href="OTEST_8H.html#a0">test</a> &lt; Criterion);
00208     }
00209 
00210     <a class="code" href="namespaceRBD__COMMON.html#a0">Real</a> MLE_D_FI::LastDerivative(<span class="keyword">const</span> ColumnVector&amp; H)
00211     { <span class="keywordflow">return</span> (Derivs.t() * H).AsScalar(); }
00212 
<a name="l00213"></a><a class="code" href="classMLE__D__FI.html#a1">00213</a>     <span class="keywordtype">void</span> <a class="code" href="classMLE__D__FI.html#a1">MLE_D_FI::Fit</a>(ColumnVector&amp; Parameters) {
00214         <a class="code" href="classTracer.html">Tracer</a> tr(<span class="stringliteral">"MLE_D_FI::Fit"</span>);
00215         <a class="code" href="classFindMaximum2.html#a0">FindMaximum2::Fit</a>(Parameters,Lim);
00216         cout &lt;&lt; <span class="stringliteral">"\nConverged\n"</span>;
00217     }
00218 
00219     <span class="keywordtype">void</span> MLE_D_FI::MakeCovariance() {
00220         <span class="keywordflow">if</span> (Covariance.Nrows()==0) {
00221             LowerTriangularMatrix LTI = LT.i();
00222             Covariance &lt;&lt; LTI.t() * LTI;
00223             SE &lt;&lt; Covariance;                           <span class="comment">// get diagonal</span>
00224             <span class="keywordtype">int</span> n = Covariance.Nrows();
00225             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i &lt;= n; i++) SE(i) = sqrt(SE(i));
00226         }
00227     }
00228 
<a name="l00229"></a><a class="code" href="classMLE__D__FI.html#a2">00229</a>     <span class="keywordtype">void</span> <a class="code" href="classMLE__D__FI.html#a2">MLE_D_FI::GetStandardErrors</a>(ColumnVector&amp; SEX)
00230     { MakeCovariance(); SEX = SE.AsColumn(); }
00231 
<a name="l00232"></a><a class="code" href="classMLE__D__FI.html#a3">00232</a>     <span class="keywordtype">void</span> <a class="code" href="classMLE__D__FI.html#a3">MLE_D_FI::GetCorrelations</a>(SymmetricMatrix&amp; Corr)
00233     { MakeCovariance(); Corr &lt;&lt; SE.i() * Covariance * SE.i(); }
00234 
00235 <span class="preprocessor">#ifdef use_namespace</span>
00236 <span class="preprocessor"></span>}
00237 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>Generated on Fri Aug 23 01:37:11 2002 for VirtualU by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.17 </small></address>
</body>
</html>
