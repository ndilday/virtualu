<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Omem.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.17 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>Omem.cpp</h1><a href="Omem_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">//Filename    : OMEM.CPP</span>
00002 <span class="comment">//Description : Object Memory Management (Debug Version)</span>
00003 
00004 <span class="preprocessor">#include &lt;string.h&gt;</span>
00005 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00006 
00007 <span class="preprocessor">#ifndef NO_MEM_CLASS</span>
00008 <span class="preprocessor"></span>
00009 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00010 <span class="preprocessor">#include &lt;<a class="code" href="ALL_8H.html">ALL.H</a>&gt;</span>                                  <span class="comment">// class Memory is declared here</span>
00011 
00012 <span class="comment">//--------- Define Constants -----------//</span>
00013 
00014 <span class="comment">// We will write the PRE_CHK_VAL before every allocated memory block</span>
00015 <span class="comment">// and POST_CHK_VAL after them, so when freeing them, we could</span>
00016 <span class="comment">// know whether they have been underrun/overun or not</span>
00017 
<a name="l00018"></a><a class="code" href="Omem_8cpp.html#a0">00018</a> <span class="preprocessor">#define CHK_VAL_SIZE    sizeof(long)</span>
00019 <span class="preprocessor"></span>
<a name="l00020"></a><a class="code" href="Omem_8cpp.html#a1">00020</a> <span class="preprocessor">#define PRE_CHK_VAL     0x12345678                // value to detect underrun</span>
<a name="l00021"></a><a class="code" href="Omem_8cpp.html#a2">00021</a> <span class="preprocessor"></span><span class="preprocessor">#define POST_CHK_VAL    0x87654321                // value to detect overrun</span>
00022 <span class="preprocessor"></span>
00023 <span class="comment">// The followings should are selected to give maximum probability that</span>
00024 <span class="comment">// pointers loaded with these values will cause an obvious crash.</span>
00025 <span class="comment">// MALLOCVAL is the value to set malloc'd data to.</span>
00026 
<a name="l00027"></a><a class="code" href="Omem_8cpp.html#a3">00027</a> <span class="preprocessor">#define BAD_VAL         0xFF                      // set to this value for freed memory (memory that we no longer occupy)</span>
<a name="l00028"></a><a class="code" href="Omem_8cpp.html#a4">00028</a> <span class="preprocessor"></span><span class="preprocessor">#define ALLOC_VAL       0xEE                      // set to this value for memory just allocated</span>
00029 <span class="preprocessor"></span>
00030 <span class="comment">//---------- define constant and structure --------//</span>
00031 
<a name="l00032"></a><a class="code" href="Omem_8cpp.html#a5">00032</a> <span class="preprocessor">#define SPOOL_MEM  50                             // 50 bytes spool memory for mem_add(),</span>
00033 <span class="preprocessor"></span>
<a name="l00036"></a><a class="code" href="structMemInfo.html">00036</a> <span class="keyword">struct </span><a class="code" href="structMemInfo.html">MemInfo</a> {
<a name="l00037"></a><a class="code" href="structMemInfo.html#m0">00037</a>     <span class="keywordtype">void</span>     *<a class="code" href="structMemInfo.html#m0">ptr</a>;                                  <span class="comment">// this pointer directly point to useable buffer</span>
<a name="l00038"></a><a class="code" href="structMemInfo.html#m1">00038</a>     <span class="keywordtype">unsigned</span> <a class="code" href="structMemInfo.html#m1">size</a>;                                  <span class="comment">// bypassing the PRE_CHK_VAL</span>
00039 
<a name="l00040"></a><a class="code" href="structMemInfo.html#m2">00040</a>     <span class="keywordtype">char</span>     *<a class="code" href="structMemInfo.html#m2">file_name</a>;
<a name="l00041"></a><a class="code" href="structMemInfo.html#m3">00041</a>     <span class="keywordtype">int</span>      <a class="code" href="structMemInfo.html#m3">file_line</a>;
00042 };
00043 
00044 <span class="comment">// global debug function to display stat in mem.info_array</span>
<a name="l00045"></a><a class="code" href="Omem_8cpp.html#a6">00045</a> size_t <a class="code" href="Omem_8cpp.html#a6">mem_usage</a>() {
00046     size_t memUsed = 0;
00047     <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i=0; i&lt;mem.ptr_used;++i ) {
00048         memUsed += mem.info_array[i].size;
00049     }
00050     <span class="keywordflow">return</span> memUsed;
00051 }
00052 
00053 <span class="comment">//-------- BEGIN OF FUNCTION Mem::Mem ------------//</span>
00054 
<a name="l00055"></a><a class="code" href="classMem.html#a0">00055</a> <a class="code" href="classMem.html#a0">Mem::Mem</a>() {
00056     <a class="code" href="classMem.html#m0">info_array</a> = <span class="keyword">new</span> <a class="code" href="structMemInfo.html">MemInfo</a>[100];
00057 
00058     <span class="keywordflow">if</span> ( <a class="code" href="classMem.html#m0">info_array</a> == <a class="code" href="OHELP_8H.html#a0">NULL</a> )
00059         err.mem();
00060 
00061     <a class="code" href="classMem.html#m1">ptr_num</a>  = 100 ;
00062     <a class="code" href="classMem.html#m2">ptr_used</a> = 0;
00063 }
00064 
00065 <span class="comment">//---------- END OF FUNCTION Mem::Mem ------------//</span>
00066 
00067 <span class="comment">//--------- BEGIN OF FUNCTION Mem::add --------------//</span>
00068 <span class="comment">//</span>
00069 <span class="comment">// &lt;unsigned&gt; memNum   = the size of the memory to be allocated</span>
00070 <span class="comment">// &lt;char*&gt;    fileName = file from which the client function calls</span>
00071 <span class="comment">// &lt;int&gt;      fileLine = line number of the client function in the file</span>
00072 <span class="comment">//</span>
<a name="l00073"></a><a class="code" href="classMem.html#a2">00073</a> <span class="keywordtype">char</span>* <a class="code" href="classMem.html#a2">Mem::add</a>(<span class="keywordtype">unsigned</span> memSize, <span class="keywordtype">char</span>* fileName, <span class="keywordtype">int</span> fileLine) {
00074     <span class="comment">// ###### begin Gilbert 29/8 ######//</span>
00075     <span class="comment">//err_when( memSize &gt; 1000000 );            //**BUGHERE, for temporary debugging only</span>
00076     <a class="code" href="ALL_8H.html#a0">err_when</a>( memSize &gt; 0x800000 );                 <span class="comment">// 8M</span>
00077     <span class="comment">// ###### end Gilbert 29/8 ######//</span>
00078 
00079     <span class="comment">//----------- build up memory pointer table ---------//</span>
00080 
00081     <span class="keywordflow">if</span> ( <a class="code" href="classMem.html#m2">ptr_used</a> == <a class="code" href="classMem.html#m1">ptr_num</a> ) {
00082         <a class="code" href="classMem.html#m1">ptr_num</a> += 100 ;
00083         <span class="keywordflow">if</span> ( <a class="code" href="classMem.html#m1">ptr_num</a> &gt; 0x7fff-100 )
00084             err.run( <span class="stringliteral">" Mem::add() - Too many pointers "</span> );
00085 
00086         <span class="comment">// ##### begin Gilbert 26/04/2001 ######//</span>
00087         <span class="comment">// info_array = (MemInfo*) realloc( info_array, sizeof(MemInfo) * ptr_num ) ;</span>
00088         <a class="code" href="structMemInfo.html">MemInfo</a> *newInfo = <span class="keyword">new</span> <a class="code" href="structMemInfo.html">MemInfo</a>[<a class="code" href="classMem.html#m1">ptr_num</a>];
00089         memcpy( newInfo, <a class="code" href="classMem.html#m0">info_array</a>, <span class="keyword">sizeof</span>(MemInfo) * <a class="code" href="classMem.html#m2">ptr_used</a> );
00090         <span class="keyword">delete</span>[] <a class="code" href="classMem.html#m0">info_array</a>;
00091         <a class="code" href="classMem.html#m0">info_array</a> = newInfo;
00092         <span class="comment">// ##### end Gilbert 26/04/2001 ######//</span>
00093 
00094         <span class="keywordflow">if</span> ( <a class="code" href="classMem.html#m0">info_array</a> == <a class="code" href="OHELP_8H.html#a0">NULL</a> )
00095             err.mem();
00096     }
00097 
00098     <span class="comment">//----------- actually allocate memory -------------//</span>
00099 
00100     <span class="keywordtype">char</span> *allocPtr;
00101 
00102     allocPtr = <span class="keyword">new</span> <span class="keywordtype">char</span>[ memSize + <a class="code" href="Omem_8cpp.html#a0">CHK_VAL_SIZE</a>*2 ];<span class="comment">// Pre-check &amp; Post-check</span>
00103 
00104     <span class="keywordflow">if</span> ( allocPtr == <a class="code" href="OHELP_8H.html#a0">NULL</a> ) {
00105         err.mem();
00106         <span class="keywordflow">return</span> <a class="code" href="OHELP_8H.html#a0">NULL</a>;
00107     }
00108     <span class="keywordflow">else</span> {
00109         <span class="comment">// set check value before and after the allocated block,</span>
00110         <span class="comment">// so Mem::del() can use these check value to detect</span>
00111         <span class="comment">// underrun &amp;&amp; overrun</span>
00112 
00113         *((<span class="keywordtype">long</span>*)allocPtr)                        = <a class="code" href="Omem_8cpp.html#a1">PRE_CHK_VAL</a>;
00114         *((<span class="keywordtype">long</span>*)(allocPtr+<a class="code" href="Omem_8cpp.html#a0">CHK_VAL_SIZE</a>+memSize)) = <a class="code" href="Omem_8cpp.html#a2">POST_CHK_VAL</a>;
00115 
00116         <span class="comment">// fill the allocated block with a value, which may</span>
00117         <span class="comment">// have chance to reveal some hiden bugs</span>
00118 
00119         memset( allocPtr+<a class="code" href="Omem_8cpp.html#a0">CHK_VAL_SIZE</a>, <a class="code" href="Omem_8cpp.html#a4">ALLOC_VAL</a>, memSize );
00120 
00121         <a class="code" href="classMem.html#m0">info_array</a>[<a class="code" href="classMem.html#m2">ptr_used</a>].ptr       = allocPtr+<a class="code" href="Omem_8cpp.html#a0">CHK_VAL_SIZE</a>;
00122         <a class="code" href="classMem.html#m0">info_array</a>[<a class="code" href="classMem.html#m2">ptr_used</a>].size      = memSize;
00123         <a class="code" href="classMem.html#m0">info_array</a>[<a class="code" href="classMem.html#m2">ptr_used</a>].file_name = fileName;
00124         <a class="code" href="classMem.html#m0">info_array</a>[<a class="code" href="classMem.html#m2">ptr_used</a>].file_line = fileLine;
00125         <a class="code" href="classMem.html#m2">ptr_used</a>++;
00126 
00127         <span class="keywordflow">return</span> allocPtr+<a class="code" href="Omem_8cpp.html#a0">CHK_VAL_SIZE</a>;
00128     }
00129 }
00130 
00131 <span class="comment">//---------- END OF FUNCTION Mem::add ---------------//</span>
00132 
00133 <span class="comment">//--------- BEGIN OF FUNCTION Mem::add_clear --------------//</span>
00134 <span class="comment">//</span>
00135 <span class="comment">// Allocate the memory and set all the memory content to byte 0.</span>
00136 <span class="comment">//</span>
00137 <span class="comment">// &lt;unsigned&gt; memNum   = the size of the memory to be allocated</span>
00138 <span class="comment">// &lt;char*&gt;    fileName = file from which the client function calls</span>
00139 <span class="comment">// &lt;int&gt;      fileLine = line number of the client function in the file</span>
00140 <span class="comment">//</span>
<a name="l00141"></a><a class="code" href="classMem.html#a3">00141</a> <span class="keywordtype">char</span>* <a class="code" href="classMem.html#a3">Mem::add_clear</a>(<span class="keywordtype">unsigned</span> memSize, <span class="keywordtype">char</span>* fileName, <span class="keywordtype">int</span> fileLine) {
00142     <a class="code" href="ALL_8H.html#a0">err_when</a>( memSize &gt; 0x800000 );                 <span class="comment">//**BUGHERE, for temporary debugging only</span>
00143 
00144     <span class="comment">//----------- build up memory pointer table ---------//</span>
00145 
00146     <span class="keywordflow">if</span> ( <a class="code" href="classMem.html#m2">ptr_used</a> == <a class="code" href="classMem.html#m1">ptr_num</a> ) {
00147         <a class="code" href="classMem.html#m1">ptr_num</a> += 100 ;
00148         <span class="keywordflow">if</span> ( <a class="code" href="classMem.html#m1">ptr_num</a> &gt; 0x7fff-100 )
00149             err.run( <span class="stringliteral">" Mem::add_clear() - Too many pointers "</span> );
00150 
00151         <span class="comment">// ##### begin Gilbert 26/04/2001 ######//</span>
00152         <span class="comment">// info_array = (MemInfo*) realloc( info_array, sizeof(MemInfo) * ptr_num ) ;</span>
00153         <a class="code" href="structMemInfo.html">MemInfo</a> *newInfo = <span class="keyword">new</span> <a class="code" href="structMemInfo.html">MemInfo</a>[<a class="code" href="classMem.html#m1">ptr_num</a>];
00154         memcpy( newInfo, <a class="code" href="classMem.html#m0">info_array</a>, <span class="keyword">sizeof</span>(MemInfo) * <a class="code" href="classMem.html#m2">ptr_used</a> );
00155         <span class="keyword">delete</span>[] <a class="code" href="classMem.html#m0">info_array</a>;
00156         <a class="code" href="classMem.html#m0">info_array</a> = newInfo;
00157         <span class="comment">// ##### end Gilbert 26/04/2001 ######//</span>
00158 
00159         <span class="keywordflow">if</span> ( <a class="code" href="classMem.html#m0">info_array</a> == <a class="code" href="OHELP_8H.html#a0">NULL</a> )
00160             err.mem();
00161     }
00162 
00163     <span class="comment">//----------- actually allocate memory -------------//</span>
00164 
00165     <span class="keywordtype">char</span> *allocPtr;
00166 
00167     allocPtr = <span class="keyword">new</span> <span class="keywordtype">char</span>[ memSize + <a class="code" href="Omem_8cpp.html#a0">CHK_VAL_SIZE</a>*2 ];<span class="comment">// Pre-check &amp; Post-check</span>
00168 
00169     <span class="keywordflow">if</span> ( allocPtr == <a class="code" href="OHELP_8H.html#a0">NULL</a> ) {
00170         err.mem();
00171         <span class="keywordflow">return</span> <a class="code" href="OHELP_8H.html#a0">NULL</a>;
00172     }
00173     <span class="keywordflow">else</span> {
00174         <span class="comment">// set check value before and after the allocated block,</span>
00175         <span class="comment">// so Mem::del() can use these check value to detect</span>
00176         <span class="comment">// underrun &amp;&amp; overrun</span>
00177 
00178         *((<span class="keywordtype">long</span>*)allocPtr)                        = <a class="code" href="Omem_8cpp.html#a1">PRE_CHK_VAL</a>;
00179         *((<span class="keywordtype">long</span>*)(allocPtr+<a class="code" href="Omem_8cpp.html#a0">CHK_VAL_SIZE</a>+memSize)) = <a class="code" href="Omem_8cpp.html#a2">POST_CHK_VAL</a>;
00180 
00181         <span class="comment">// fill the allocated block with a value, which may</span>
00182         <span class="comment">// have chance to reveal some hiden bugs</span>
00183 
00184         memset( allocPtr+<a class="code" href="Omem_8cpp.html#a0">CHK_VAL_SIZE</a>, 0, memSize );
00185 
00186         <a class="code" href="classMem.html#m0">info_array</a>[<a class="code" href="classMem.html#m2">ptr_used</a>].ptr       = allocPtr+<a class="code" href="Omem_8cpp.html#a0">CHK_VAL_SIZE</a>;
00187         <a class="code" href="classMem.html#m0">info_array</a>[<a class="code" href="classMem.html#m2">ptr_used</a>].size      = memSize;
00188         <a class="code" href="classMem.html#m0">info_array</a>[<a class="code" href="classMem.html#m2">ptr_used</a>].file_name = fileName;
00189         <a class="code" href="classMem.html#m0">info_array</a>[<a class="code" href="classMem.html#m2">ptr_used</a>].file_line = fileLine;
00190         <a class="code" href="classMem.html#m2">ptr_used</a>++;
00191 
00192         <span class="keywordflow">return</span> allocPtr+<a class="code" href="Omem_8cpp.html#a0">CHK_VAL_SIZE</a>;
00193     }
00194 }
00195 
00196 <span class="comment">//---------- END OF FUNCTION Mem::add_clear ---------------//</span>
00197 
00198 <span class="comment">//-------- BEGIN OF FUNCTION Mem::resize_keep_data ----------//</span>
00199 <span class="comment">//</span>
00200 <span class="comment">// The Mem::resize() and realloc() may not function properly in</span>
00201 <span class="comment">// some case when the memory block has a considerable size.</span>
00202 <span class="comment">//</span>
00203 <span class="comment">// Calling this function resize_keep_data will do additional effort</span>
00204 <span class="comment">// to preserve the original data.</span>
00205 <span class="comment">//</span>
00206 <span class="comment">// &lt;void*&gt;    orgPtr    = the original memory data pointer</span>
00207 <span class="comment">// &lt;unsigned&gt; orgSize   = the original data size</span>
00208 <span class="comment">// &lt;unsigned&gt; newSize   = new size of memory required</span>
00209 <span class="comment">// &lt;char*&gt;    fileName  = file from which the client function calls</span>
00210 <span class="comment">// &lt;int&gt;      fileLine  = line number of the client function in the file</span>
00211 <span class="comment">//</span>
00212 <span class="comment">// Returns : NULL    - not enough memory</span>
00213 <span class="comment">//           &lt;char*&gt; - pointer to the allocated memory</span>
00214 <span class="comment">//</span>
<a name="l00215"></a><a class="code" href="classMem.html#a5">00215</a> <span class="keywordtype">char</span>* <a class="code" href="classMem.html#a5">Mem::resize_keep_data</a>(<span class="keywordtype">void</span> *orgPtr, <span class="keywordtype">unsigned</span> orgSize, <span class="keywordtype">unsigned</span> newSize, <span class="keywordtype">char</span>* fileName, <span class="keywordtype">int</span> fileLine) {
00216     <span class="keywordflow">if</span>( orgPtr == <a class="code" href="OHELP_8H.html#a0">NULL</a> &amp;&amp; newSize == 0 )
00217         <span class="keywordflow">return</span> <a class="code" href="OHELP_8H.html#a0">NULL</a>;
00218 
00219     <span class="keywordflow">if</span>( orgPtr == <a class="code" href="OHELP_8H.html#a0">NULL</a> )
00220         <span class="keywordflow">return</span> <a class="code" href="classMem.html#a2">add</a>( newSize, fileName, fileLine);
00221 
00222     <span class="keywordflow">if</span>( newSize &lt;= orgSize )
00223         <span class="keywordflow">return</span> <a class="code" href="classMem.html#a4">resize</a>(orgPtr, newSize, fileName, fileLine);
00224 
00225     <span class="comment">//-------- save the original data first ------//</span>
00226 
00227     <span class="keywordtype">char</span>* saveBuf = <span class="keyword">new</span> <span class="keywordtype">char</span>[orgSize];
00228 
00229     memcpy( saveBuf, orgPtr, orgSize );
00230 
00231     <span class="comment">//------ reallocate the memory --------//</span>
00232 
00233     <span class="keywordtype">char</span>* newPtr = <a class="code" href="classMem.html#a4">resize</a>(orgPtr, newSize, fileName, fileLine);
00234 
00235     <span class="comment">//----- store the original data to the new buf -------//</span>
00236     <span class="comment">//</span>
00237     <span class="comment">// if the new pointer is the same as the orginal pointer</span>
00238     <span class="comment">// the original data should be kept without any change</span>
00239     <span class="comment">//</span>
00240     <span class="comment">//----------------------------------------------------//</span>
00241 
00242     <span class="keywordflow">if</span>( newPtr != orgPtr )
00243         memcpy( newPtr, saveBuf, orgSize );
00244 
00245     <span class="keyword">delete</span>[] saveBuf;
00246 
00247     <span class="keywordflow">return</span> newPtr;
00248 }
00249 
00250 <span class="comment">//----------- END OF FUNCTION Mem::resize_keep_data ---------------//</span>
00251 
00252 <span class="comment">//-------- BEGIN OF FUNCTION Mem::resize ----------//</span>
00253 <span class="comment">//</span>
00254 <span class="comment">// &lt;void*&gt;    orgPtr = the original memory data pointer</span>
00255 <span class="comment">// &lt;unsigned&gt; memSize   = new size of memory required</span>
00256 <span class="comment">// &lt;char*&gt;    fileName  = file from which the client function calls</span>
00257 <span class="comment">// &lt;int&gt;      fileLine  = line number of the client function in the file</span>
00258 <span class="comment">//</span>
00259 <span class="comment">// Returns : NULL    - not enough memory</span>
00260 <span class="comment">//           &lt;char*&gt; - pointer to the allocated memory</span>
00261 <span class="comment">//</span>
00262 <span class="comment">// Note : resize() must actually call realloc(), it can't call mem()</span>
00263 <span class="comment">//        and add(), because some clients want to keep the content on the</span>
00264 <span class="comment">//        existing buffer. (e.g. DynArray)</span>
00265 <span class="comment">//</span>
<a name="l00266"></a><a class="code" href="classMem.html#a4">00266</a> <span class="keywordtype">char</span>* <a class="code" href="classMem.html#a4">Mem::resize</a>(<span class="keywordtype">void</span> *orgPtr, <span class="keywordtype">unsigned</span> memSize, <span class="keywordtype">char</span>* fileName, <span class="keywordtype">int</span> fileLine) {
00267     <span class="comment">//  err_when( memSize &gt; 0x800000 );         //**BUGHERE, for temporary debugging only               //## fred 1204</span>
00268 
00269     <span class="keywordflow">if</span>( orgPtr == <a class="code" href="OHELP_8H.html#a0">NULL</a> &amp;&amp; memSize == 0 )
00270         <span class="keywordflow">return</span> <a class="code" href="OHELP_8H.html#a0">NULL</a>;
00271 
00272     <span class="keywordflow">if</span>( orgPtr == <a class="code" href="OHELP_8H.html#a0">NULL</a> )
00273         <span class="keywordflow">return</span> <a class="code" href="classMem.html#a2">add</a>( memSize, fileName, fileLine);
00274 
00275     <span class="keywordflow">if</span>( memSize == 0 ) {
00276         <a class="code" href="classMem.html#a6">del</a>( orgPtr, fileName, fileLine );
00277         <span class="keywordflow">return</span> <a class="code" href="OHELP_8H.html#a0">NULL</a>;
00278     }
00279 
00280     <span class="comment">//-------------------------------------------//</span>
00281 
00282     <span class="keywordtype">char</span> *newPtr;
00283     <span class="keywordtype">int</span>  i;
00284 
00285     <span class="keywordflow">for</span>( i=<a class="code" href="classMem.html#m2">ptr_used</a>-1; i&gt;=0; i-- ) {
00286         <span class="keywordflow">if</span>( <a class="code" href="classMem.html#m0">info_array</a>[i].<a class="code" href="structMemInfo.html#m0">ptr</a> == orgPtr ) {
00287             <span class="keywordflow">if</span>( <a class="code" href="classMem.html#m0">info_array</a>[i].<a class="code" href="structMemInfo.html#m1">size</a> != memSize ) {
00288                 <span class="comment">// Remember : MemInfo::ptr points directly to client buffer,</span>
00289                 <span class="comment">//            bypassing the PRE_CHK_VAL</span>
00290 
00291                 <span class="comment">// newPtr = (char*) realloc( (char*)orgPtr-CHK_VAL_SIZE, memSize+CHK_VAL_SIZE*2 );</span>
00292                 newPtr = <span class="keyword">new</span> <span class="keywordtype">char</span>[memSize+<a class="code" href="Omem_8cpp.html#a0">CHK_VAL_SIZE</a>*2];
00293 
00294                 <span class="keywordflow">if</span>( newPtr == <a class="code" href="OHELP_8H.html#a0">NULL</a> )
00295                     err.mem();
00296 
00297                 memcpy( newPtr, (<span class="keywordtype">char</span> *)orgPtr-<a class="code" href="Omem_8cpp.html#a0">CHK_VAL_SIZE</a>, <a class="code" href="Omem_8cpp.html#a0">CHK_VAL_SIZE</a>+min(memSize,<a class="code" href="classMem.html#m0">info_array</a>[i].size) );
00298                 <span class="keyword">delete</span>[] ((<span class="keywordtype">char</span> *)orgPtr -<a class="code" href="Omem_8cpp.html#a0">CHK_VAL_SIZE</a> );
00299 
00300                 <span class="comment">// set the POST_CHK_VAL again as the size of it has changed</span>
00301 
00302                 *((<span class="keywordtype">long</span>*)newPtr)                        = <a class="code" href="Omem_8cpp.html#a1">PRE_CHK_VAL</a>;
00303                 *((<span class="keywordtype">long</span>*)(newPtr+<a class="code" href="Omem_8cpp.html#a0">CHK_VAL_SIZE</a>+memSize)) = <a class="code" href="Omem_8cpp.html#a2">POST_CHK_VAL</a>;
00304 
00305                 <a class="code" href="classMem.html#m0">info_array</a>[i].<a class="code" href="structMemInfo.html#m0">ptr</a>  = newPtr + <a class="code" href="Omem_8cpp.html#a0">CHK_VAL_SIZE</a>;
00306                 <a class="code" href="classMem.html#m0">info_array</a>[i].<a class="code" href="structMemInfo.html#m1">size</a> = memSize;
00307             }
00308 
00309             <span class="keywordflow">return</span> (<span class="keywordtype">char</span>*) <a class="code" href="classMem.html#m0">info_array</a>[i].<a class="code" href="structMemInfo.html#m0">ptr</a>;
00310         }
00311     }
00312 
00313     err.run( <span class="stringliteral">"Mem::resize - Original memory pointer not found.\n"</span>
00314              <span class="stringliteral">"File name : %s, line no. : %d \n"</span>, fileName, fileLine );
00315 
00316     <span class="keywordflow">return</span> <a class="code" href="OHELP_8H.html#a0">NULL</a>;
00317 }
00318 
00319 <span class="comment">//----------- END OF FUNCTION Mem::resize ---------------//</span>
00320 
00321 <span class="comment">//-------- BEGIN OF FUNCTION Mem::del ----------//</span>
00322 <span class="comment">//</span>
00323 <span class="comment">// &lt;void*&gt;    freePtr   = the memory data pointer to be freed</span>
00324 <span class="comment">// &lt;char*&gt;    fileName  = file from which the client function calls</span>
00325 <span class="comment">// &lt;int&gt;      fileLine  = line number of the client function in the file</span>
00326 <span class="comment">//</span>
<a name="l00327"></a><a class="code" href="classMem.html#a6">00327</a> <span class="keywordtype">void</span> <a class="code" href="classMem.html#a6">Mem::del</a>(<span class="keywordtype">void</span> *freePtr, <span class="keywordtype">char</span>* fileName, <span class="keywordtype">int</span> fileLine) {
00328 <span class="preprocessor">#ifdef DEBUG</span>
00329 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( !<a class="code" href="classMem.html#m0">info_array</a> ) {
00330         err.msg( <span class="stringliteral">"Mem::del - Free memory after ~Mem, File name:%s, line no.:%d\n"</span>, fileName, fileLine );
00331         <span class="keywordflow">return</span>;
00332     }
00333 <span class="preprocessor">#endif</span>
00334 <span class="preprocessor"></span>
00335     <span class="keywordtype">int</span>   i ;
00336     <span class="keywordtype">char</span>* truePtr;
00337 
00338     <span class="keywordflow">for</span>( i=<a class="code" href="classMem.html#m2">ptr_used</a>-1; i&gt;=0; i-- ) {
00339         <span class="keywordflow">if</span>( <a class="code" href="classMem.html#m0">info_array</a>[i].<a class="code" href="structMemInfo.html#m0">ptr</a> == freePtr ) {
00340             <span class="comment">// truePtr is the pointer actually point to the start of the allocated block, including PRE_CHK_VAL</span>
00341 
00342             truePtr = (<span class="keywordtype">char</span>*) freePtr - <a class="code" href="Omem_8cpp.html#a0">CHK_VAL_SIZE</a>;
00343 
00344             <span class="comment">//---- Check for Underwrite and Overwrite error ---//</span>
00345 
00346             <span class="keywordflow">if</span>( *((<span class="keywordtype">long</span>*)truePtr) != <a class="code" href="Omem_8cpp.html#a1">PRE_CHK_VAL</a> )
00347                 err.run( <span class="stringliteral">"Mem::del - Memory Underwritten, File name:%s, line no.:%d\n"</span>, fileName, fileLine );
00348 
00349             <span class="keywordflow">if</span>( *((<span class="keywordtype">long</span>*)(truePtr+<a class="code" href="Omem_8cpp.html#a0">CHK_VAL_SIZE</a>+<a class="code" href="classMem.html#m0">info_array</a>[i].<a class="code" href="structMemInfo.html#m1">size</a>)) != <a class="code" href="Omem_8cpp.html#a2">POST_CHK_VAL</a> )
00350                 err.run( <span class="stringliteral">"Mem::del - Memory Overwritten, File name:%s, line no.:%d\n"</span>, fileName, fileLine );
00351 
00352             <span class="comment">// fill the to be freed block with a value, which may</span>
00353             <span class="comment">// have chance to reveal some hiden bugs</span>
00354 
00355             memset( truePtr+<a class="code" href="Omem_8cpp.html#a0">CHK_VAL_SIZE</a>, <a class="code" href="Omem_8cpp.html#a3">BAD_VAL</a>, <a class="code" href="classMem.html#m0">info_array</a>[i].size );
00356 
00357             <span class="comment">//--------- free it up --------------//</span>
00358 
00359             <span class="keyword">delete</span>[] truePtr;
00360 
00361             memmove( <a class="code" href="classMem.html#m0">info_array</a>+i, <a class="code" href="classMem.html#m0">info_array</a>+i+1, <span class="keyword">sizeof</span>(<a class="code" href="structMemInfo.html">MemInfo</a>) * (<a class="code" href="classMem.html#m2">ptr_used</a>-i-1) ) ;
00362             <a class="code" href="classMem.html#m2">ptr_used</a>-- ;
00363             <span class="keywordflow">return</span> ;
00364         }
00365     }
00366 
00367     err.run( <span class="stringliteral">"Mem::del - Free value not found, File name:%s, line no.:%d\n"</span>, fileName, fileLine );
00368 }
00369 
00370 <span class="comment">//----------- END OF FUNCTION Mem::del ---------------//</span>
00371 
00372 <span class="comment">//-------- BEGIN OF FUNCTION Mem::get_mem_size ----------//</span>
00373 <span class="comment">//</span>
00374 <span class="comment">// This function is mainly for debugging only.</span>
00375 <span class="comment">//</span>
00376 <span class="comment">// &lt;void*&gt; memPtr   = the memory data pointer to be freed</span>
00377 <span class="comment">//</span>
<a name="l00378"></a><a class="code" href="classMem.html#a7">00378</a> <span class="keywordtype">int</span> <a class="code" href="classMem.html#a7">Mem::get_mem_size</a>(<span class="keywordtype">void</span> *memPtr) {
00379     <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i=<a class="code" href="classMem.html#m2">ptr_used</a>-1; i&gt;=0; i-- ) {
00380         <span class="keywordflow">if</span>( <a class="code" href="classMem.html#m0">info_array</a>[i].<a class="code" href="structMemInfo.html#m0">ptr</a> == memPtr )
00381             <span class="keywordflow">return</span> <a class="code" href="classMem.html#m0">info_array</a>[i].<a class="code" href="structMemInfo.html#m1">size</a>;
00382     }
00383 
00384     err.run( <span class="stringliteral">"Error: Mem::get_mem_size()."</span> );
00385 
00386     <span class="keywordflow">return</span> 0;
00387 }
00388 
00389 <span class="comment">//----------- END OF FUNCTION Mem::get_mem_size ---------------//</span>
00390 
00391 <span class="comment">//-------- BEGIN OF FUNCTION Mem::~Mem ------------//</span>
00392 
<a name="l00393"></a><a class="code" href="classMem.html#a1">00393</a> <a class="code" href="classMem.html#a1">Mem::~Mem</a>() {
00394     <span class="keywordflow">if</span> ( <a class="code" href="classMem.html#m2">ptr_used</a> &gt; 0 ) {
00395         <span class="keywordtype">int</span> i;
00396 
00397         <span class="keywordflow">for</span> ( i=0; i&lt; <a class="code" href="classMem.html#m2">ptr_used</a> ; i++ ) {
00398             err.msg( <span class="stringliteral">"Memory not freed. File name : %s, line no. : %d \n"</span>,
00399                      <a class="code" href="classMem.html#m0">info_array</a>[i].file_name, <a class="code" href="classMem.html#m0">info_array</a>[i].file_line );
00400         }
00401     }
00402 
00403     <span class="keyword">delete</span>[] <a class="code" href="classMem.html#m0">info_array</a>;
00404     <a class="code" href="classMem.html#m0">info_array</a> = <a class="code" href="OHELP_8H.html#a0">NULL</a>;                              <span class="comment">// to mark sub-sequence mem_del issue a message</span>
00405 }
00406 
00407 <span class="comment">//---------- END OF FUNCTION Mem::~Mem ------------//</span>
00408 
00409 <span class="comment">/*</span>
00410 <span class="comment"></span>
00411 <span class="comment">//-------- Begin of Overload "new" operator --------//</span>
00412 <span class="comment"></span>
00413 <span class="comment">void* operator new(size_t memSize)</span>
00414 <span class="comment">{</span>
00415 <span class="comment">   void *memPtr = malloc(memSize);</span>
00416 <span class="comment"></span>
00417 <span class="comment">   return memPtr;</span>
00418 <span class="comment">}</span>
00419 <span class="comment"></span>
00420 <span class="comment">//--------- End of Overload "new" operator ---------//</span>
00421 <span class="comment"></span>
00422 <span class="comment">//-------- Begin of Overload "delete" operator --------//</span>
00423 <span class="comment"></span>
00424 <span class="comment">void operator delete(void *memPtr)</span>
00425 <span class="comment">{</span>
00426 <span class="comment">free(memPtr);</span>
00427 <span class="comment">}</span>
00428 <span class="comment"></span>
00429 <span class="comment">//--------- End of Overload "delete" operator ---------//</span>
00430 <span class="comment"></span>
00431 <span class="comment">*/</span>
00432 
00433 <span class="preprocessor">#else</span>
00434 <span class="preprocessor"></span>
00435 <span class="comment">//-------- BEGIN OF FUNCTION mem_resize_keep_data ----------//</span>
00436 <span class="comment">//</span>
00437 <span class="comment">// This is the non-DEBUG version of Mem::resize_keep_data()</span>
00438 <span class="comment">//</span>
00439 <span class="comment">// &lt;void*&gt;    orgPtr    = the original memory data pointer</span>
00440 <span class="comment">// &lt;unsigned&gt; orgSize   = the original data size</span>
00441 <span class="comment">// &lt;unsigned&gt; newSize   = new size of memory required</span>
00442 <span class="comment">//</span>
00443 <span class="comment">// Returns : NULL    - not enough memory</span>
00444 <span class="comment">//           &lt;char*&gt; - pointer to the allocated memory</span>
00445 <span class="comment">//</span>
00446 <span class="keywordtype">char</span>* <a class="code" href="ALL_8H.html#a9">mem_resize_keep_data</a>(<span class="keywordtype">void</span> *orgPtr, <span class="keywordtype">unsigned</span> orgSize, <span class="keywordtype">unsigned</span> newSize) {
00447     <span class="keywordflow">if</span>( orgPtr == <a class="code" href="OHELP_8H.html#a0">NULL</a> &amp;&amp; newSize == 0 )
00448         <span class="keywordflow">return</span> <a class="code" href="OHELP_8H.html#a0">NULL</a>;
00449 
00450     <span class="keywordflow">if</span>( orgPtr == <a class="code" href="OHELP_8H.html#a0">NULL</a> )
00451         <span class="keywordflow">return</span> (<span class="keywordtype">char</span>*) malloc(newSize);
00452 
00453     <span class="keywordflow">if</span>( newSize &lt;= orgSize )
00454         <span class="keywordflow">return</span> (<span class="keywordtype">char</span>*) realloc(orgPtr, newSize);
00455 
00456     <span class="comment">//-------- save the original data first ------//</span>
00457 
00458     <span class="keywordtype">char</span>* saveBuf = <span class="keyword">new</span> <span class="keywordtype">char</span>[orgSize];
00459 
00460     memcpy( saveBuf, orgPtr, orgSize );
00461 
00462     <span class="comment">//------ reallocate the memory --------//</span>
00463 
00464     <span class="keywordtype">char</span>* newPtr = (<span class="keywordtype">char</span>*) realloc(orgPtr, newSize);
00465 
00466     <span class="comment">//----- store the original data to the new buf -------//</span>
00467 
00468     <span class="keywordflow">if</span>( newPtr != orgPtr )                          <span class="comment">// only when the pointer has been changed</span>
00469         memcpy( newPtr, saveBuf, orgSize );
00470 
00471     <span class="keyword">delete</span>[] saveBuf;
00472 
00473     <span class="keywordflow">return</span> newPtr;
00474 }
00475 
00476 <span class="comment">//----------- END OF FUNCTION mem_resize_keep_data ---------------//</span>
00477 <span class="preprocessor">#endif</span>
00478 <span class="preprocessor"></span>
00479 <span class="comment">//-----------------------------------------------------//</span>
00480 <span class="comment">//</span>
00481 <span class="comment">// An article from Walter Bright's MEM Package which is</span>
00482 <span class="comment">// very similar to our omem class</span>
00483 <span class="comment">//</span>
00484 <span class="comment">// WHAT MEM DOES:</span>
00485 <span class="comment">// --------------</span>
00486 <span class="comment">//</span>
00487 <span class="comment">// 1.    ISO/ANSI verification:</span>
00488 <span class="comment">//</span>
00489 <span class="comment">// When Walter wrote MEM, compiler compliance with ANSI standards was still</span>
00490 <span class="comment">// quite low.  MEM verifies ISO/ANSI compliance for situations such as passing</span>
00491 <span class="comment">// NULL or size 0 to allocation/reallocation functions.</span>
00492 <span class="comment">//</span>
00493 <span class="comment">// 2.    Logging of all allocations and frees:</span>
00494 <span class="comment">//</span>
00495 <span class="comment">// All MEM's functions pass the __FILE__ and __LINE__ arguments.  During alloca-</span>
00496 <span class="comment">// tion, MEM makes an entry into a linked list and stores the file and line</span>
00497 <span class="comment">// information in the list for whichever allocation or free function is called.</span>
00498 <span class="comment">//</span>
00499 <span class="comment">// This linked list is the backbone of MEM.  When MEM detects a bug, it tells</span>
00500 <span class="comment">// you where to look in which file to begin tracking the problem.</span>
00501 <span class="comment">//</span>
00502 <span class="comment">// 3.    Verification of frees:</span>
00503 <span class="comment">//</span>
00504 <span class="comment">// Since MEM knows about all allocations, when a pointer is freed, MEM can</span>
00505 <span class="comment">// verify that the pointer was allocated originally.  Additionally, MEM will</span>
00506 <span class="comment">// only allow a pointer to be freed once.</span>
00507 <span class="comment">//</span>
00508 <span class="comment">// Freed data is overwritten with a non-zero known value, flushing such problems</span>
00509 <span class="comment">// as continuing to reference data after it's been freed.  The value written</span>
00510 <span class="comment">// over the data is selected to maximize the probability of a segment fault or</span>
00511 <span class="comment">// assertion failure if your application references it after it's been freed.</span>
00512 <span class="comment">//</span>
00513 <span class="comment">// MEM obviously can't directly detect "if" instances such as...</span>
00514 <span class="comment">//</span>
00515 <span class="comment">//       mem_free(p);</span>
00516 <span class="comment">//             if (p) ...</span>
00517 <span class="comment">//</span>
00518 <span class="comment">// ...but by guaranteeing that `p' points to garbage after being freed, code</span>
00519 <span class="comment">// like this will hopefully never work and will thus be easier to find.</span>
00520 <span class="comment">//</span>
00521 <span class="comment">// 4.    Detection of pointer over- and under-run:</span>
00522 <span class="comment">//</span>
00523 <span class="comment">// Pointer overrun occurs when a program stores data past the end of a buffer,</span>
00524 <span class="comment">// e.g.</span>
00525 <span class="comment">//</span>
00526 <span class="comment">//       p = malloc(strlen(s));        /* No space for terminating NUL      */</span>
00527 <span class="comment">//       strcpy(p,s);                  /* Terminating NUL clobber memory   */</span>
00528 <span class="comment">//</span>
00529 <span class="comment">// Pointer underrun occurs when a program stores data before the beginning of a</span>
00530 <span class="comment">// buffer.  This error occurs less often than overruns, but MEM detects it</span>
00531 <span class="comment">// anyway.  MEM does this by allocating a little extra at each end of every</span>
00532 <span class="comment">// buffer, which is filled with a known value, called a sentinel. MEM detects</span>
00533 <span class="comment">// overruns and underruns by verifying the sentinel value when the buffer is</span>
00534 <span class="comment">// freed.</span>
00535 <span class="comment">//</span>
00536 <span class="comment">// 5.    Dependence on values in buffer obtained from malloc():</span>
00537 <span class="comment">//</span>
00538 <span class="comment">// When obtaining a buffer from malloc(), a program may develop erroneous and</span>
00539 <span class="comment">// creeping dependencies on whatever random (and sometimes repeatable) values</span>
00540 <span class="comment">// the buffer may contain.  The mem_malloc() function prevents this by always</span>
00541 <span class="comment">// setting the data in a buffer to a known non-zero value before returning its</span>
00542 <span class="comment">// pointer.  This also prevents another common error when running under MS-DOS</span>
00543 <span class="comment">// which doesn't clear unused memory when loading a program.  These bugs are</span>
00544 <span class="comment">// particularly nasty to find since correct program operation may depend on what</span>
00545 <span class="comment">// was last run!</span>
00546 <span class="comment">//</span>
00547 <span class="comment">// 6.    Realloc problems:</span>
00548 <span class="comment">//</span>
00549 <span class="comment">// Common problems when using realloc() are: 1) depending on realloc() *not*</span>
00550 <span class="comment">// shifting the location of the buffer in memory, and 2) depending on finding</span>
00551 <span class="comment">// certain values in the uninitialized region of the realloc'ed buffer.</span>
00552 <span class="comment">//</span>
00553 <span class="comment">// MEM flushes these out by *always* moving the buffer and stomping on values</span>
00554 <span class="comment">// past the initialized area.</span>
00555 <span class="comment">//</span>
00556 <span class="comment">// 7.    Memory leak detection:</span>
00557 <span class="comment">//</span>
00558 <span class="comment">// Memory "leaks" are areas that are allocated but never freed.  This can become</span>
00559 <span class="comment">// a major problem in programs that must run for long periods without interrup-</span>
00560 <span class="comment">// tion (e.g. BBS's).  If there are leaks, eventually the program will run out</span>
00561 <span class="comment">// of memory and fail.</span>
00562 <span class="comment">//</span>
00563 <span class="comment">// Another form of memory leak occurs when a piece of allocated memory should</span>
00564 <span class="comment">// have been added to some central data structure, but wasn't.</span>
00565 <span class="comment">//</span>
00566 <span class="comment">// MEM find memory leaks by keeping track of all allocations and frees.  When</span>
00567 <span class="comment">// mem_term() is called, a list of all unfreed allocations is printed along with</span>
00568 <span class="comment">// the files and line numbers where the allocations occurred.</span>
00569 <span class="comment">//</span>
00570 <span class="comment">// 8.    Pointer checking:</span>
00571 <span class="comment">//</span>
00572 <span class="comment">// Sometimes it's useful to be able to verify that a pointer is actually</span>
00573 <span class="comment">// pointing into free store. MEM provides a function...</span>
00574 <span class="comment">//</span>
00575 <span class="comment">//       mem_checkptr(void *p);</span>
00576 <span class="comment">//</span>
00577 <span class="comment">// ...to do this.</span>
00578 <span class="comment">//</span>
00579 <span class="comment">// 9.    Consistency checking:</span>
00580 <span class="comment">//</span>
00581 <span class="comment">// Occasionally, even MEM's internal data structures get clobbered by a wild</span>
00582 <span class="comment">// pointer.  When this happens, you can track it down by sprinkling your code</span>
00583 <span class="comment">// temporarily with calls to mem_check(), which performs a consistency check on</span>
00584 <span class="comment">// the free store.</span>
00585 <span class="comment">//</span>
00586 <span class="comment">// 10.   Out of memory handling:</span>
00587 <span class="comment">//</span>
00588 <span class="comment">// MEM can be set using mem_setexception() (see MEM.H) to handle out-of-memory</span>
00589 <span class="comment">// conditions in any one of several predefined ways:</span>
00590 <span class="comment">//</span>
00591 <span class="comment">//       1.    Present an "Out of memory" message and terminate the program.</span>
00592 <span class="comment">//       2.    Abort the program with no message.</span>
00593 <span class="comment">//       3.    Mimic ISO/ANSI and return NULL.</span>
00594 <span class="comment">//       4.    Call a user-specified function, perhaps involving virtual memory</span>
00595 <span class="comment">//          or some other "emergency reserve".</span>
00596 <span class="comment">//       5.    Retry (be careful to avoid infinite loops!)</span>
00597 <span class="comment">//</span>
00598 <span class="comment">// 11.   Companion techniques:</span>
00599 <span class="comment">//</span>
00600 <span class="comment">// Since MEM presets allocated and stomps on freed memory, this facilitates</span>
00601 <span class="comment">// adding your own code to add tags to your data structures when debugging.  If</span>
00602 <span class="comment">// the structures are invalid, you'll know it because MEM will have clobbered</span>
00603 <span class="comment">// your verification tags.</span>
00604 <span class="comment">//</span>
00605 <span class="comment">//-----------------------------------------------------//</span>
</pre></div><hr><address style="align: right;"><small>Generated on Fri Aug 23 01:38:05 2002 for VirtualU by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.17 </small></address>
</body>
</html>
